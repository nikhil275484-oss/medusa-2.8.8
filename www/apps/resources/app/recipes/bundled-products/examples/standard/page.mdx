---
sidebar_label: "Bundled Products"
tags:
    - name: cart
      label: "Implement Bundled Products"
    - server
    - tutorial
    - name: product
      label: "Implement Bundled Products"
products:
  - cart
  - product
---

import { Github, PlaySolid } from "@medusajs/icons"
import { Prerequisites, WorkflowDiagram, CardList } from "docs-ui"

export const metadata = {
  title: `Implement Bundled Products in Medusa`,
}

# {metadata.title}

In this tutorial, you'll learn how to implement bundled products in Medusa.

When you install a Medusa application, you get a fully-fledged commerce platform with a Framework for customization. The Medusa application's commerce features are built around [Commerce Modules](../../../../commerce-modules/page.mdx), which are available out-of-the-box.

Medusa natively supports [inventory kits](../../../../commerce-modules/inventory/inventory-kit/page.mdx), which can be used to create bundled products. However, inventory kits don't support all features of bundled products, such as fulfilling the products in the bundle separately.

In this tutorial, you'll use Medusa's customizable Framework to implement bundled products. By building the bundled products feature, you can expand on it based on what's necessary for your use case.

You can follow this tutorial whether you're new to Medusa or an advanced Medusa developer.

## Summary

By following this tutorial, you'll learn how to:

- Install and set up a Medusa application.
- Define models for bundled products.
- Link bundled products to Medusa's existing product model, allowing you to benefit from existing product features.
- Customize the add-to-cart flow to support bundled products.
- Customize the Next.js Starter Storefront to display bundled products.

![Bundled products system architecture diagram showing the relationship between bundled products and individual products and variants](https://res.cloudinary.com/dza7lstvk/image/upload/v1745855513/Medusa%20Resources/bundled-products-overview_r5zejm.jpg)

<CardList items={[
  {
    href: "https://github.com/medusajs/examples/tree/main/bundled-products",
    title: "Bundled Products Repository",
    text: "Find the full code for this guide in this repository.",
    icon: Github,
  },
  {
    href: "https://res.cloudinary.com/dza7lstvk/raw/upload/v1746024108/OpenApi/Bundled_Products_vloupx.yaml",
    title: "OpenApi Specs for Postman",
    text: "Import this OpenApi Specs file into tools like Postman.",
    icon: PlaySolid,
  },
]} />

---

## Step 1: Install a Medusa Application

<Prerequisites items={[
  {
    text: "Node.js v20+",
    link: "https://nodejs.org/en/download"
  },
  {
    text: "Git CLI tool",
    link: "https://git-scm.com/downloads"
  },
  {
    text: "PostgreSQL",
    link: "https://www.postgresql.org/download/"
  }
]} />

Start by installing the Medusa application on your machine with the following command:

```bash
npx create-medusa-app@latest
```

You'll first be asked for the project's name. Then, when asked whether you want to install the [Next.js Starter Storefront](../../../../nextjs-starter/page.mdx), choose Yes.

Afterward, the installation process will start, which will install the Medusa application in a directory with your project's name, and the Next.js Starter Storefront in a separate directory with the `{project-name}-storefront` name.

<Note title="Why is the storefront installed separately">

The Medusa application is composed of a headless Node.js server and an admin dashboard. The storefront is installed or custom-built separately and connects to the Medusa application through its REST endpoints, called [API routes](!docs!/learn/fundamentals/api-routes). Learn more in [Medusa's Architecture documentation](!docs!/learn/introduction/architecture).

</Note>

Once the installation finishes successfully, the Medusa Admin dashboard will open with a form to create a new user. Enter the user's credentials and submit the form. Afterward, you can log in with the new user and explore the dashboard.

<Note title="Ran into Errors">

Check out the [troubleshooting guides](../../../../troubleshooting/create-medusa-app-errors/page.mdx) for help.

</Note>

---

## Step 2: Create Bundled Product Module

In Medusa, you can build custom features in a [module](!docs!/learn/fundamentals/modules). A module is a reusable package with functionalities related to a single feature or domain. Medusa integrates the module into your application without implications or side effects on your setup.

In the module, you define the data models necessary for a feature and the logic to manage these data models. Later, you can build commerce flows around your module.

In this step, you'll build a Bundled Product Module that defines the necessary data models to store and manage bundled products.

<Note>

Refer to the [Modules documentation](!docs!/learn/fundamentals/modules) to learn more.

</Note>

### Create Module Directory

Modules are created under the `src/modules` directory of your Medusa application. So, create the directory `src/modules/bundled-product`.

### Create Data Models

A data model represents a table in the database. You create data models using Medusa's Data Model Language (DML). It simplifies defining a table's columns, relations, and indexes with straightforward methods and configurations.

<Note>

Refer to the [Data Models documentation](!docs!/learn/fundamentals/modules#1-create-data-model) to learn more.

</Note>

For the Bundled Product Module, you need to define two data models:

- `Bundle` for the bundle itself.
- `BundleItem` for the items in the bundle.

To create the `Bundle` data model, create the file `src/modules/bundled-product/models/bundle.ts` with the following content:

export const bundleHighlights = [
  ["5", "id", "Unique ID for the bundle"],
  ["6", "title", "The bundle's title"],
  ["7", "items", "The items in the bundle"],
]

```ts title="src/modules/bundled-product/models/bundle.ts" highlights={bundleHighlights}
import { model } from "@medusajs/framework/utils"
import { BundleItem } from "./bundle-item"

export const Bundle = model.define("bundle", {
  id: model.id().primaryKey(),
  title: model.text(),
  items: model.hasMany(() => BundleItem, {
    mappedBy: "bundle",
  }),
})
```

You define the `Bundle` data model using the `model.define` method of the DML. It accepts the data model's table name as a first parameter, and the model's schema object as a second parameter.

The `Bundle` data model has the following properties:

- `id`: A unique ID for the bundle.
- `title`: The bundle's title.
- `items`: A one-to-many relation to the `BundleItem` data model, which you'll create next.

<Note>

Learn more about defining data model properties in the [Property Types documentation](!docs!/learn/fundamentals/data-models/properties).

</Note>

To create the `BundleItem` data model, create the file `src/modules/bundled-product/models/bundle-item.ts` with the following content:

export const bundleItemHighlights = [
  ["5", "id", "Unique ID for the bundle item"],
  ["6", "quantity", "The quantity of the item in the bundle"],
  ["7", "bundle", "The bundle this item belongs to"],
]

```ts title="src/modules/bundled-product/models/bundle-item.ts" highlights={bundleItemHighlights}
import { model } from "@medusajs/framework/utils"
import { Bundle } from "./bundle"

export const BundleItem = model.define("bundle_item", {
  id: model.id().primaryKey(),
  quantity: model.number().default(1),
  bundle: model.belongsTo(() => Bundle, {
    mappedBy: "items",
  }),
})
```

The `BundleItem` data model has the following properties:

- `id`: A unique ID for the bundle item.
- `quantity`: The quantity of the item in the bundle. It defaults to `1`.
- `bundle`: A many-to-one relation to the `Bundle` data model, which you defined earlier.

<Note>

Learn more about defining data model relations in the [Relations documentation](!docs!/learn/fundamentals/data-models/relationships).

</Note>

### Create Module's Service

You now have the necessary data models in the Bundled Product Module, but you'll need to manage their records. You do this by creating a service in the module.

A service is a TypeScript or JavaScript class that the module exports. In the service's methods, you can connect to the database, allowing you to manage your data models, or connect to a third-party service, which is useful if you're integrating with external services.

<Note>

Refer to the [Module Service documentation](!docs!/learn/fundamentals/modules#2-create-service) to learn more.

</Note>

To create the Bundled Product Module's service, create the file `src/modules/bundled-product/service.ts` with the following content:

```ts title="src/modules/bundled-product/service.ts"
import { MedusaService } from "@medusajs/framework/utils"
import { Bundle } from "./models/bundle"
import { BundleItem } from "./models/bundle-item"

export default class BundledProductModuleService extends MedusaService({
  Bundle,
  BundleItem,
}) {
}
```

The `BundledProductModuleService` extends `MedusaService` from the Modules SDK which generates a class with data-management methods for your module's data models. This saves you time on implementing Create, Read, Update, and Delete (CRUD) methods.

So, the `BundledProductModuleService` class now has methods like `createBundles` and `retrieveBundleItem`.

<Note>

Find all methods generated by the `MedusaService` in [the Service Factory reference](../../../../service-factory-reference/page.mdx).

</Note>

### Export Module Definition

The final piece to a module is its definition, which you export in an `index.ts` file at its root directory. This definition tells Medusa the name of the module and its service.

So, create the file `src/modules/bundled-product/index.ts` with the following content:

```ts title="src/modules/bundled-product/index.ts"
import { Module } from "@medusajs/framework/utils"
import BundledProductsModuleService from "./service"

export const BUNDLED_PRODUCT_MODULE = "bundledProduct"

export default Module(BUNDLED_PRODUCT_MODULE, {
  service: BundledProductsModuleService,
})
```

You use the `Module` function from the Modules SDK to create the module's definition. It accepts two parameters:

1. The module's name, which is `bundledProduct`. The name can only contain alphanumeric characters and underscores.
2. An object with a required property `service` indicating the module's service.

You also export the module's name as `BUNDLED_PRODUCT_MODULE` so you can reference it later.

### Add Module to Medusa's Configurations

Once you finish building the module, add it to Medusa's configurations to start using it.

In `medusa-config.ts`, add a `modules` property and pass an array with your custom module:

```ts title="medusa-config.ts"
module.exports = defineConfig({
  // ...
  modules: [
    {
      resolve: "./src/modules/bundled-product",
    },
  ],
})
```

Each object in the `modules` array has a `resolve` property, whose value is either a path to the module's directory, or an `npm` package’s name.

### Generate Migrations

Since data models represent tables in the database, you define how they're created in the database with migrations. A migration is a TypeScript or JavaScript file that defines database changes made by a module.

<Note>

Refer to the [Migrations documentation](!docs!/learn/fundamentals/modules#5-generate-migrations) to learn more.

</Note>

Medusa's CLI tool can generate the migrations for you. To generate a migration for the Bundled Product Module, run the following command in your Medusa application's directory:

```bash
npx medusa db:generate bundledProduct
```

The `db:generate` command of the Medusa CLI accepts the name of the module to generate the migration for. You'll now have a `migrations` directory under `src/modules/bundled-product` that holds the generated migration.

Then, to reflect these migrations on the database, run the following command:

```bash
npx medusa db:migrate
```

The tables for the `Bundle` and `BundleItem` data models are now created in the database.

---

## Step 3: Link Bundles to Medusa Products

Medusa integrates modules into your application without implications or side effects by isolating modules from one another. This means you can't directly create relationships between data models in your module and data models in other modules.

Instead, Medusa provides the mechanism to define links between data models, and retrieve and manage linked records while maintaining module isolation. Links are useful to define associations between data models in different modules, or extend a model in another module to associate custom properties with it.

<Note>

Refer to the [Module Isolation documentation](!docs!/learn/fundamentals/modules/isolation) to learn more.

</Note>

In this step, you'll define a link between:

- The `Bundle` data model in the Bundled Product Module and the `Product` data model in the Products Module. This link will allow you to benefit from existing product features, like prices, sales channels, and more.
- The `BundleItem` data model in the Bundled Product Module and the `Product` data model in the Products Module. This link will allow you to associate a bundle item with an existing product, where the customer chooses from their variants when purchasing the bundle.

<Note title="Tip">

Refer to the [Product Module's data models reference](/references/product/models) to learn more about available data models in the Products Module.

</Note>

### Bundle \<\> Product Link

You can define links between data models in a TypeScript or JavaScript file under the `src/links` directory.

So, to define the link between a bundle and a product, create the file `src/links/bundle-product.ts` with the following content:

```ts title="src/links/bundle-product.ts"
import { defineLink } from "@medusajs/framework/utils"
import ProductModule from "@medusajs/medusa/product"
import BundledProductsModule from "../modules/bundled-product"

export default defineLink(
  BundledProductsModule.linkable.bundle,
  ProductModule.linkable.product
)
```

You define a link using the `defineLink` function from the Modules SDK. It accepts two parameters:

1. An object indicating the first data model part of the link. A module has a special `linkable` property that contains link configurations for its data models. So, you can pass the link configurations for the `Bundle` data model from the Bundled Product module.
2. An object indicating the second data model part of the link. You pass the linkable configurations of the Product Module's `Product` data model.

You'll later learn how to query and manage the linked records.

### BundleItem \<\> Product Link

Next, you'll define the link between the `BundleItem` data model and the `Product` data model. Create the file `src/links/bundle-item-product.ts` with the following content:

```ts title="src/links/bundle-item-product.ts"
import { defineLink } from "@medusajs/framework/utils"
import ProductModule from "@medusajs/medusa/product"
import BundledProductsModule from "../modules/bundled-product"

export default defineLink(
  {
    linkable: BundledProductsModule.linkable.bundleItem,
    isList: true,
  },
  ProductModule.linkable.product
)
```

You define the link in the same way as the previous one, but you pass an object with a `isList` property set to `true` for the first parameter. This indicates that the link is a one-to-many relation, meaning that a product can be linked to multiple bundle items.

### Sync Links to Database

Medusa creates a table in the database for each link you define. So, you must run the migrations again to create the necessary tables:

```bash
npx medusa db:migrate
```

This will create tables for both links in the database. The tables will later store the IDs of the linked records.

<Note>

Refer to the [Module Links](!docs!/learn/fundamentals/module-links) documentation to learn more about defining links and link tables.

</Note>

---

## Step 4: Create Bundled Product Workflow

You're now ready to start implementing bundled-product features. The first one you'll implement is the ability to create a bundled product.

To build custom commerce features in Medusa, you create a [workflow](!docs!/learn/fundamentals/workflows). A workflow is a series of queries and actions, called steps, that complete a task. By using workflows, you can track their executions' progress, define roll-back logic, and configure other advanced features.

So, in this section, you'll learn how to create a workflow that creates a bundled product. Later, you'll execute this workflow in an API route.

<Note>

Learn more about workflows in the [Workflows documentation](!docs!/learn/fundamentals/workflows).

</Note>

The workflow will have the following steps:

<WorkflowDiagram
  workflow={{
    name: "createBundledProductWorkflow",
    steps: [
      {
        name: "createBundleStep",
        type: "step",
        description: "Create a bundle",
        depth: 1
      },
      {
        name: "createBundleItemStep",
        type: "step",
        description: "Create the bundle items",
        depth: 1
      },
      {
        name: "createProductsWorkflow",
        type: "workflow",
        description: "Create the Medusa product associated with the bundle",
        depth: 1,
        link: "/references/medusa-workflows/createProductsWorkflow"
      },
      {
        name: "createRemoteLinkStep",
        type: "step",
        description: "Create the link between the bundle and the Medusa product",
        depth: 1,
        link: "/references/helper-steps/createRemoteLinkStep"
      },
      {
        name: "createRemoteLinkStep",
        type: "step",
        description: "Create the link between the bundle items and the Medusa products",
        depth: 1,
        link: "/references/helper-steps/createRemoteLinkStep"
      },
      {
        name: "useQueryGraphStep",
        type: "step",
        description: "Retrieve the created bundle and its items.",
        depth: 1,
        link: "/references/helper-steps/useQueryGraphStep"
      }
    ]
  }}
  hideLegend
/>

You only need to implement the first two steps, as Medusa provides the rest in its `@medusajs/medusa/core-flows` package.

### createBundleStep

The first step of the workflow creates a bundle using the Bundled Product Module's service.

To create the step, create the file `src/workflows/steps/create-bundle.ts` with the following content:

export const createBundleStepHighlights = [
  ["12", "bundledProductModuleService", "Resolve the Bundled Module's service."],
  ["15", "createBundles", "Create a bundle."],
  ["19", "bundle", "Return the created bundle."],
  ["19", "id", "Pass the ID to the compensation function."],
  ["28", "deleteBundles", "Delete the bundles to undo the step's actions."]
]

```ts title="src/workflows/steps/create-bundle.ts" highlights={createBundleStepHighlights}
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import BundledProductModuleService from "../../modules/bundled-product/service"
import { BUNDLED_PRODUCT_MODULE } from "../../modules/bundled-product"

type CreateBundleStepInput = {
  title: string
}

export const createBundleStep = createStep(
  "create-bundle",
  async ({ title }: CreateBundleStepInput, { container }) => {
    const bundledProductModuleService: BundledProductModuleService =
      container.resolve(BUNDLED_PRODUCT_MODULE)

    const bundle = await bundledProductModuleService.createBundles({
      title,
    })

    return new StepResponse(bundle, bundle.id)
  },
  async (bundleId, { container }) => {
    if (!bundleId) {
      return
    }
    const bundledProductModuleService: BundledProductModuleService =
      container.resolve(BUNDLED_PRODUCT_MODULE)
      
    await bundledProductModuleService.deleteBundles(bundleId)
  }
)
```

You create a step with `createStep` from the Workflows SDK. It accepts two parameters:

1. The step's unique name, which is `create-bundle`.
2. An async function that receives two parameters:
    - The step's input, which is in this case an object with the bundle's properties.
    - An object that has properties including the [Medusa container](!docs!/learn/fundamentals/medusa-container), which is a registry of Framework and commerce tools that you can access in the step.

In the step function, you resolve the Bundled Product Module's service from the Medusa container using its `resolve` method, passing it the module's name as a parameter.

Then, you create the bundle using the `createBundles` method. As you remember, the Bundled Product Module's service extends the `MedusaService` which generates data-management methods for you.

A step function must return a `StepResponse` instance. The `StepResponse` constructor accepts two parameters:

1. The step's output, which is the bundle created.
2. Data to pass to the step's compensation function.

<Note>

Learn more about creating a step in the [Workflow documentation](!docs!/learn/fundamentals/workflows).

</Note>

#### Compensation Function

The compensation function undoes the actions performed in a step. Then, if an error occurs during the workflow's execution, the compensation functions of executed steps are called to roll back the changes. This mechanism ensures data consistency in your application, especially as you integrate external systems.

The compensation function accepts two parameters:

1. The data passed from the step in the second parameter of `StepResponse`, which in this case is the ID of the created bundle.
2. An object that has properties including the [Medusa container](!docs!/learn/fundamentals/medusa-container).

In the compensation function, you resolve the Bundled Product Module's service from the Medusa container and call the `deleteBundles` method to delete the bundle created in the step.

<Note>

Refer to the [Compensation Function documentation](!docs!/learn/fundamentals/workflows/compensation-function) to learn more.

</Note>

### createBundleItemStep

Next, you'll create the second step that creates the items in the bundle.

To create the step, create the file `src/workflows/steps/create-bundle-items.ts` with the following content:

export const createBundleItemsStepHighlights = [
  ["15", "bundledProductModuleService", "Resolve the Bundled Module's service."],
  ["18", "createBundleItems", "Create the bundle items."],
  ["25", "bundleItems", "Return the created bundle items."],
  ["25", "map", "Pass the IDs to the compensation function."],
  ["35", "deleteBundleItems", "Delete the bundle items to undo the step's actions."]
]

```ts title="src/workflows/steps/create-bundle-items.ts" highlights={createBundleItemsStepHighlights}
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { BUNDLED_PRODUCT_MODULE } from "../../modules/bundled-product"
import BundledProductModuleService from "../../modules/bundled-product/service"

type CreateBundleItemsStepInput = {
  bundle_id: string
  items: {
    quantity: number
  }[]
}

export const createBundleItemsStep = createStep(
  "create-bundle-items",
  async ({ bundle_id, items }: CreateBundleItemsStepInput, { container }) => {
    const bundledProductModuleService: BundledProductModuleService =
      container.resolve(BUNDLED_PRODUCT_MODULE)

    const bundleItems = await bundledProductModuleService.createBundleItems(
      items.map((item) => ({
        bundle_id,
        quantity: item.quantity,
      }))
    )

    return new StepResponse(bundleItems, bundleItems.map((item) => item.id))
  },
  async (itemIds, { container }) => {
    if (!itemIds?.length) {
      return
    }

    const bundledProductModuleService: BundledProductModuleService =
      container.resolve(BUNDLED_PRODUCT_MODULE)

    await bundledProductModuleService.deleteBundleItems(itemIds)
  }
)
```

This step accepts the bundle ID and an array of bundle items to create.

In the step, you resolve the Bundled Product Module's service to create the bundle items. Then, you return the created bundle items.

You also pass the IDs of the created bundle items to the compensation function. In the compensation function, you delete the bundle items created in the step.

### Create Workflow

Now that you have all the necessary steps, you can create the workflow.

To create the workflow, create the file `src/workflows/create-bundled-product.ts` with the following content:

export const createBundledProductWorkflowHighlights = [
  ["23", "createBundleStep", "Create the bundle."],
  ["27", "createBundleItemsStep", "Create the bundle items."],
  ["32", "createProductsWorkflow", "Create the Medusa product associated with the bundle."],
  ["38", "createRemoteLinkStep", "Create a link between the bundle and the Medusa product."],
  ["47", "transform", "Prepare the data to create links between bundle items and Medusa products."],
  ["61", "createRemoteLinkStep", "Create the links between the bundle items and the Medusa products."],
  ["66", "useQueryGraphStep", "Retrieve the created bundle and its items."],
]

```ts title="src/workflows/create-bundled-product.ts" highlights={createBundledProductWorkflowHighlights}
import { CreateProductWorkflowInputDTO } from "@medusajs/framework/types"
import { createWorkflow, transform, WorkflowResponse } from "@medusajs/framework/workflows-sdk"
import { createBundleStep } from "./steps/create-bundle"
import { createBundleItemsStep } from "./steps/create-bundle-items"
import { createProductsWorkflow, createRemoteLinkStep, useQueryGraphStep } from "@medusajs/medusa/core-flows"
import { BUNDLED_PRODUCT_MODULE } from "../modules/bundled-product"
import { Modules } from "@medusajs/framework/utils"

export type CreateBundledProductWorkflowInput = {
  bundle: {
    title: string
    product: CreateProductWorkflowInputDTO
    items: {
      product_id: string
      quantity: number
    }[]
  }
}

export const createBundledProductWorkflow = createWorkflow(
  "create-bundled-product",
  ({ bundle: bundleData }: CreateBundledProductWorkflowInput) => {
    const bundle = createBundleStep({
      title: bundleData.title,
    })

    const bundleItems = createBundleItemsStep({
      bundle_id: bundle.id,
      items: bundleData.items,
    })
    
    const bundleProduct = createProductsWorkflow.runAsStep({
      input: {
        products: [bundleData.product],
      },
    })

    createRemoteLinkStep([{
      [BUNDLED_PRODUCT_MODULE]: {
        bundle_id: bundle.id,
      },
      [Modules.PRODUCT]: {
        product_id: bundleProduct[0].id,
      },
    }])

    const bundleProducttemLinks = transform({
      bundleData,
      bundleItems,
    }, (data) => {
      return data.bundleItems.map((item, index) => ({
        [BUNDLED_PRODUCT_MODULE]: {
          bundle_item_id: item.id,
        },
        [Modules.PRODUCT]: {
          product_id: data.bundleData.items[index].product_id,
        },
      }))
    })

    createRemoteLinkStep(bundleProducttemLinks).config({
      name: "create-bundle-product-items-links",
    })

    // retrieve bundled product with items
    const { data } = useQueryGraphStep({
      entity: "bundle",
      fields: ["*", "items.*"],
      filters: {
        id: bundle.id,
      },
    })

    return new WorkflowResponse(data[0])
  }
)
```

You create a workflow using `createWorkflow` from the Workflows SDK. It accepts the workflow's unique name as a first parameter.

It accepts as a second parameter a constructor function, which is the workflow's implementation. The function can accept input, which in this case is an object holding the details of the bundle to create.

In the workflow's constructor function, you:

1. Create the bundle using the `createBundleStep`.
2. Create the bundle items using the `createBundleItemsStep`.
3. Create the Medusa product associated with the bundle using the `createProductsWorkflow`.
4. Create a link between the bundle and the Medusa product using the `createRemoteLinkStep`.
    - To create a link, you pass an array of objects. The keys of each object are the module names, and the values are objects with the IDs of the records to link.
5. Use `transform` to prepare the data to link bundle items to products.
    - You must use the `transform` function whenever you want to manipulate data in a workflow, as Medusa creates an internal representation of the workflow when the application starts, not when the workflow is executed. Learn more in the [Transform Data documentation](!docs!/learn/fundamentals/workflows/variable-manipulation).
6. Create a link between the bundle items and the Medusa products using the `createRemoteLinkStep`.
7. Retrieve the bundle and its items using the `useQueryGraphStep`.
    - `useQueryGraphStep` uses [Query](!docs!/learn/fundamentals/module-links/query), which allows you to retrieve data across modules.

A workflow must return an instance of `WorkflowResponse`. The `WorkflowResponse` constructor accepts the workflow's output as a parameter, which is the created bundle.

You'll test out this API route in a later step when you customize the Medusa Admin dashboard.

---

## Step 5: Create Bundled Product API Route

Now that you have the logic to create a bundled product, you need to expose it so that frontend clients, such as the Medusa Admin, can use it. You do this by creating an [API route](!docs!/learn/fundamentals/api-routes).

An API Route is an endpoint that exposes commerce features to external applications and clients, such as admin dashboards or storefronts. You'll create an API route at the path `/admin/bundled-products` that executes the workflow from the previous step.

<Note>

Refer to the [API Routes documentation](!docs!/learn/fundamentals/api-routes) to learn more.

</Note>

### Implement API Route

An API route is created in a `route.ts` file under a sub-directory of the `src/api` directory. The path of the API route is the file's path relative to `src/api`.

So, to create an API route at the path `/admin/bundled-products`, create the file `src/api/admin/bundled-products/route.ts` with the following content:

<Note title="Tip">

API routes starting with `/admin` are protected by default. So, only authenticated admin users can access them.

</Note>

export const bundledProductsRouteHighlights = [
  ["14", "PostBundledProductsSchema", "Define the request body schema."],
  ["31", "createBundledProductWorkflow", "Execute the workflow to create a bundled product."],
  ["38", "json", "Return the created bundle in the response."]
]

```ts title="src/api/admin/bundled-products/route.ts" highlights={bundledProductsRouteHighlights}
import { 
  AuthenticatedMedusaRequest, 
  MedusaResponse,
} from "@medusajs/framework/http"
import { z } from "zod"
import { 
  AdminCreateProduct,
} from "@medusajs/medusa/api/admin/products/validators"
import { 
  createBundledProductWorkflow, 
  CreateBundledProductWorkflowInput,
} from "../../../workflows/create-bundled-product"

export const PostBundledProductsSchema = z.object({
  title: z.string(),
  product: AdminCreateProduct(),
  items: z.array(z.object({
    product_id: z.string(),
    quantity: z.number(),
  })),
})

type PostBundledProductsSchema = z.infer<typeof PostBundledProductsSchema>

export async function POST(
  req: AuthenticatedMedusaRequest<PostBundledProductsSchema>,
  res: MedusaResponse
) {
  const { 
    result: bundledProduct,
  } = await createBundledProductWorkflow(req.scope)
    .run({
      input: {
        bundle: req.validatedBody,
      } as CreateBundledProductWorkflowInput,
    })

  res.json({
    bundled_product: bundledProduct,
  })
}
```

You first define a validation schema with [Zod](https://zod.dev/). You'll use this schema in a bit to enforce validation on requests sent to this API route.

Since you export a `POST` route handler function, you expose a `POST` API route at `/admin/bundled-products`. The route handler function accepts two parameters:

1. A request object with details and context on the request, such as body parameters or authenticated customer details.
2. A response object to manipulate and send the response.

<Note title="Tip">

`AuthenticatedMedusaRequest` accepts the request body's type as a type argument.

</Note>

In the route handler function, you execute the `createBundledProductWorkflow` by invoking it, passing it the Medusa container (which is available on the `scope` property of the request object), then calling its `run` method.

You pass the request body parameters as an input to the workflow.

Finally, you return the created bundle in the response.

### Add Validation Middleware

Now that you have the API route, you need to enforce validation on requests send to the route. You can do this with a [middleware](!docs!/learn/fundamentals/api-routes/middlewares).

A middleware is a function executed when a request is sent to an API Route. It's executed before the route handler.

<Note>

Learn more in the [Middlewares documentation](!docs!/learn/fundamentals/api-routes/middlewares).

</Note>

Middlewares are created in the `src/api/middlewares.ts` file. So create the file `src/api/middlewares.ts` with the following content:

export const middlewaresHighlights = [
  ["7", "defineMiddlewares", "Define the middlewares."],
  ["10", "matcher", "The path of the route the middleware applies to."],
  ["11", "methods", "The HTTP methods the middleware applies to."],
  ["12", "middlewares", "An array of middleware functions to apply to the route."],
  ["13", "validateAndTransformBody", "Validate the request body."],
]

```ts title="src/api/middlewares.ts" highlights={middlewaresHighlights}
import {
  defineMiddlewares, 
  validateAndTransformBody,
} from "@medusajs/framework/http"
import { PostBundledProductsSchema } from "./admin/bundled-products/route"

export default defineMiddlewares({
  routes: [
    {
      matcher: "/admin/bundled-products",
      methods: ["POST"],
      middlewares: [
        validateAndTransformBody(PostBundledProductsSchema),
      ],
    },
  ],
})
```

To export the middlewares, you use the `defineMiddlewares` function. It accepts an object having a `routes` property, whose value is an array of middleware route objects. Each middleware route object has the following properties:

- `method`: The HTTP methods the middleware applies to, which is in this case `POST`.
- `matcher`: The path of the route the middleware applies to.
- `middlewares`: An array of middleware functions to apply to the route. 
    - You apply the `validateAndTransformBody` that validates that the request body parameters match the Zod schema passed as a parameter.

The create bundled product route is now ready for use. You'll use it in an upcoming step when you customize the Medusa Admin dashboard.

---

## Step 6: Retrieve Bundles API Route

Before you start customizing the Medusa Admin, you need an API route that retrieves all bundles. You'll use this API route to show the bundles in a table on the Medusa Admin dashboard.

To create the API route, add the following at the end of `src/api/admin/bundled-products/route.ts`:

export const getBundledProductsRouteHighlights = [
  ["5", "query", "Resolve Query from the Medusa container."],
  ["10", "graph", "Retrieve the bundles."],
  ["12", "queryConfig", "Pass the query configurations."],
  ["15", "json", "Return the bundles in the response."]
]

```ts title="src/api/admin/bundled-products/route.ts" highlights={getBundledProductsRouteHighlights}
export async function GET(
  req: AuthenticatedMedusaRequest,
  res: MedusaResponse
) {
  const query = req.scope.resolve("query")

  const { 
    data: bundledProducts, 
    metadata: { count, take, skip } = {}, 
  } = await query.graph({
    entity: "bundle",
    ...req.queryConfig,
  })

  res.json({
    bundled_products: bundledProducts,
    count: count || 0,
    limit: take || 15,
    offset: skip || 0,
  })
}
```

Since you export a `GET` route handler function, you expose a `GET` API route at `/admin/bundled-products`.

In the route handler, you resolve [Query](!docs!/learn/fundamentals/module-links/query) from the Medusa container. Then, you call its `graph` method to retrieve the bundles.

Notice that you pass to `query.graph` the `req.queryConfig` object. This object contains default query configurations related to pagination and the fields to be retrieved. You'll learn how to set the query configurations in a bit.

Finally, you return the bundles in the response with pagination parameters.

### Add Query Configurations

In the API route, you use the Query configurations to determine the fields to retrieve and pagination parameters. These can be configured in a middleware, allowing you to set the default value, but also allowing clients to modify them.

To add the query configurations, add a new middleware object in `src/api/middlewares.ts`:

export const getBundledProductsMiddlewareHighlights = [
  ["12", "validateAndTransformQuery", "Validate query parameters and attach Query configurations."],
  ["12", "createFindParams", "Create a Zod schema containing pagination and field parameters."],
  ["13", "defaults", "The default fields and relations to retrieve."],
  ["20", "isList", "Whether the API route returns a list of items."],
  ["21", "defaultLimit", "The default number of items to retrieve in a page."]
]

```ts title="src/api/middlewares.ts" highlights={getBundledProductsMiddlewareHighlights}
// other imports...
import { validateAndTransformQuery } from "@medusajs/framework/http"
import { createFindParams } from "@medusajs/medusa/api/utils/validators"

export default defineMiddlewares({
  routes: [
    // ...
    {
      matcher: "/admin/bundled-products",
      methods: ["GET"],
      middlewares: [
        validateAndTransformQuery(createFindParams(), {
          defaults: [
            "id", 
            "title", 
            "product.*", 
            "items.*", 
            "items.product.*",
          ],
          isList: true,
          defaultLimit: 15,
        }),
      ],
    },
  ],
})
```

You apply the `validateAndTransformQuery` middleware on `GET` requests to `/admin/bundled-products`. It accepts the following parameters:

1. A Zod schema to validate query parameters. You use Medusa's `createFindParams` function, which creates a Zod schema containing the following query parameters:
    - `fields`: The fields to retrieve in a bundle.
    - `limit`: The maximum number of bundles to retrieve.
    - `offset`: The number of bundles to skip before retrieving the bundles.
    - `order`: The fields to sort the result by.
2. An object of Query configurations that you accessed in the API route handler using `req.queryConfig`. It accepts the following parameters:
    - `defaults`: The default fields and relations to retrieve. You retrieve the bundle, its linked product, and its items with their linked products.
    - `isList`: Whether the API route returns a list of items.
    - `defaultLimit`: The default number of items to retrieve in a page.

Your API route is now ready for use. You'll test it out in the next step as you customize the Medusa Admin dashboard.

---

## Step 7: Add Bundles Page to Medusa Admin

Now that you have the necessary routes for admin users to manage and view bundled products, you'll customize the Medusa Admin to allow admin users to use these features.

You can add a new page to the Medusa Admin dashboard using a [UI route](!docs!/learn/fundamentals/admin/ui-routes). A UI route is a React component that specifies the content to be shown in a new page in the Medusa Admin dashboard.

You'll create a UI route to display the list of bundled products in the Medusa Admin. Later, you'll add a form to create a bundled product.

<Note>

Learn more in the [UI Routes documentation](!docs!/learn/fundamentals/admin/ui-routes).

</Note>

### Initialize JS SDK

Medusa provides a [JS SDK](../../../../js-sdk/page.mdx) that you can use to send requests to the Medusa server from any client application, including your Medusa Admin customizations.

The JS SDK is installed by default in your Medusa application. To configure it, create the file `src/admin/lib/sdk.ts` with the following content:

```ts title="src/admin/lib/sdk.ts"
import Medusa from "@medusajs/js-sdk"

export const sdk = new Medusa({
  baseUrl: "http://localhost:9000",
  debug: process.env.NODE_ENV === "development",
  auth: {
    type: "session",
  },
})
```

You create an instance of the JS SDK using the `Medusa` class from the JS SDK. You pass it an object having the following properties:

- `baseUrl`: The base URL of the Medusa server.
- `debug`: A boolean indicating whether to log debug information into the console.
- `auth`: An object specifying the authentication type. When using the JS SDK for admin customizations, you use the `session` authentication type.

### Create UI Route

UI routes are created under the `src/admin/routes` directory in a `page.tsx` file. The file's path, relative to `src/admin/routes`, is used as the page's path in the Medusa Admin dashboard.

So, to create a new page that shows the list of bundled products, create the file `src/admin/routes/bundled-products/page.tsx` with the following content:

export const bundledProductsPageHighlights = [
  ["4", "BundledProductsPage", "The React component that renders the content of the new page."],
  ["8", "defineRouteConfig", "The configurations necessary to add a sidebar link for the UI route."]
]

```tsx title="src/admin/routes/bundled-products/page.tsx" highlights={bundledProductsPageHighlights}
import { defineRouteConfig } from "@medusajs/admin-sdk"
import { CubeSolid } from "@medusajs/icons"

const BundledProductsPage = () => {
  // TODO add implementation
}

export const config = defineRouteConfig({
  label: "Bundled Products",
  icon: CubeSolid,
})

export default BundledProductsPage
```

In a UI route's file, you must export:

1. A React component that defines the page's content. You'll add the content in a bit.
2. A configuration object that indicates the title and icon used in the sidebar for the page.

Next, you'll use the [DataTable](!ui!/components/data-table) component from Medusa UI to show the list of bundled products in a table.

Add the following before the `BundledProductsPage` component:

export const bundledProductsPageHighlights2 = [
  ["14", "BundledProduct", "The type of the bundled product."],
  ["34", "columns", "Define the columns of the table."],
  ["66", "limit", "The maximum number of bundles to retrieve in a page."],
]

```tsx title="src/admin/routes/bundled-products/page.tsx" highlights={bundledProductsPageHighlights2}
import { 
  Container,
  Heading,
  DataTable,
  useDataTable,
  createDataTableColumnHelper,
  DataTablePaginationState,
} from "@medusajs/ui"
import { useQuery } from "@tanstack/react-query"
import { useMemo, useState } from "react"
import { sdk } from "../../lib/sdk"
import { Link } from "react-router-dom"

type BundledProduct = {
  id: string
  title: string
  product: {
    id: string
  }
  items: {
    id: string
    product: {
      id: string
      title: string
    }
    quantity: number
  }[]
  created_at: Date
  updated_at: Date
}

const columnHelper = createDataTableColumnHelper<BundledProduct>()

const columns = [
  columnHelper.accessor("id", {
    header: "ID",
  }),
  columnHelper.accessor("title", {
    header: "Title",
  }),
  columnHelper.accessor("items", {
    header: "Items",
    cell: ({ row }) => {
      return row.original.items.map((item) => (
        <div key={item.id}>
          <Link to={`/products/${item.product.id}`}>
            {item.product.title}
          </Link>{" "}
          x {item.quantity}
        </div>
      ))
    },
  }),
  columnHelper.accessor("product", {
    header: "Product",
    cell: ({ row }) => {
      return (
        <Link to={`/products/${row.original.product?.id}`}>
          View Product
        </Link>
      )
    },
  }),
]

const limit = 15
```

You define the table's columns using `createDataTableColumnHelper` from Medusa UI. The table has the following columns:

- `ID`: The ID of the bundle.
- `Title`: The title of the bundle.
- `Items`: The items in the bundle. You show the title and quantity of each associated product with a link to its page.
- `Product`: A link to the Medusa product associated with the bundle.

You also define a `limit` constant that indicates the maximum number of bundles to retrieve in a page.

<Note>

Learn more about the `createDataTableColumnHelper` function in the [DataTable documentation](!ui!/components/data-table#columns-preparation).

</Note>

Next, replace the `BundledProductsPage` with the following implementation:

export const bundledProductsPageHighlights3 = [
  ["2", "pagination", "The pagination state of the table."],
  ["7", "offset", "The number of items to skip before retrieving the bundles."],
  ["11", "useQuery", "Retrieve the bundles from the API route."],
  ["25", "useDataTable", "Initialize the table instance."],
]

```tsx title="src/admin/routes/bundled-products/page.tsx" highlights={bundledProductsPageHighlights3}
const BundledProductsPage = () => {
  const [pagination, setPagination] = useState<DataTablePaginationState>({
    pageSize: limit,
    pageIndex: 0,
  })

  const offset = useMemo(() => {
    return pagination.pageIndex * limit
  }, [pagination])

  const { data, isLoading } = useQuery<{
    bundled_products: BundledProduct[]
    count: number
  }>({
    queryKey: ["bundled-products", offset, limit],
    queryFn: () => sdk.client.fetch("/admin/bundled-products", {
      method: "GET",
      query: {
        limit,
        offset,
      },
    }),
  })

  const table = useDataTable({
    columns,
    data: data?.bundled_products ?? [],
    isLoading,
    pagination: {
      state: pagination,
      onPaginationChange: setPagination,
    },
    rowCount: data?.count ?? 0,
  })

  return (
    <Container className="divide-y p-0">
      <DataTable instance={table}>
        <DataTable.Toolbar 
          className="flex items-start justify-between gap-2 md:flex-row md:items-center"
        >
          <Heading>Bundled Products</Heading>
        </DataTable.Toolbar>
        <DataTable.Table />
        <DataTable.Pagination />
      </DataTable>
    </Container>
  )
}
```

In the component, you define a state variable `pagination` to manage the pagination state of the table, and a memoized variable `offset` to calculate the number of items to skip before retrieving the bundles based on the current page.

Then, you use the `useQuery` hook from [Tanstack (React) Query](https://tanstack.com/query/latest) to retrieve the bundles from the API route. Tanstack Query is a data-fetching library with features like caching, pagination, and background updates.

In the query function of `useQuery`, you use the JS SDK to send a `GET` request to `/admin/bundled-products` of the Medusa server. You pass the `limit` and `offset` query parameters to support paginating the bundles.

Next, you initialize a table instance using the `useDataTable` hook from Medusa UI. Finally, you render the table in the page.

### Test it Out

To test out the UI route, start the Medusa application by running the following command:

```bash npm2yarn
npm run dev
```

Then, open the Medusa Admin dashboard in your browser at `http://localhost:9000/app` and log in.

After you log in, you'll see a new "Bundled Products" item in the sidebar. Click on it to open the Bundled Products page.

The table will be empty as you haven't added any bundled products yet. You'll add the form to create a bundled product next.

![Bundled Product page with empty table](https://res.cloudinary.com/dza7lstvk/image/upload/v1745919655/Medusa%20Resources/Screenshot_2025-04-29_at_12.30.30_PM_nvsezf.png)

---

## Step 8: Create Bundled Product Form

In this step, you'll add a form that allows admin users to create a bundled product. The form will be shown in a modal when the user clicks on a "Create" button in the Bundled Products page.

The form will have the following fields:

- The title of the bundle.
- For each bundle item, a selector to choose the associated product, and a quantity input field.

### Create Form Component

To create the component that shows the form, create the file `src/admin/components/create-bundled-product.tsx` with the following content:

export const createBundledProductComponentHighlights = [
  ["16", "open", "Whether the modal is open or closed."],
  ["17", "title", "The title of the bundle."],
  ["18", "items", "The items in the bundle."],
]

```tsx title="src/admin/components/create-bundled-product.tsx" highlights={createBundledProductComponentHighlights} collapsibleLines="1-13" expandButtonLabel="Show Imports"
import { 
  Button,
  FocusModal,
  Heading,
  Input,
  Label,
  Select,
  toast,
} from "@medusajs/ui"
import { useState, useRef, useCallback, useMemo } from "react"
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
import { sdk } from "../lib/sdk"
import { HttpTypes } from "@medusajs/framework/types"

const CreateBundledProduct = () => {
  const [open, setOpen] = useState(false)
  const [title, setTitle] = useState("")
  const [items, setItems] = useState<{
    product_id: string | undefined
    quantity: number
  }[]>([
    {
      product_id: undefined,
      quantity: 1,
    },
  ])
  // TODO fetch products
}
export default CreateBundledProduct
```

You create a `CreateBundledProduct` component that defines the following state variables:

- `open`: A boolean indicating whether the modal is open or closed.
- `title`: The title of the bundle.
- `items`: An array of objects representing the items in the bundle. Each object has the following properties:
    - `product`: The ID of the product.
    - `quantity`: The quantity of the product in the bundle.

### Fetch Products in Form Component

Next, you need to retrieve the list of products in Medusa to show them in a selector input. Replace the `TODO` in the `CreateBundledProduct` with the following:

export const createBundledProductComponentHighlights2 = [
  ["1", "products", "The products to show in the selector."],
  ["2", "productsLimit", "The maximum number of products to retrieve."],
  ["3", "currentProductPage", "The current page of products retrieved from the server."],
  ["4", "productsCount", "The total number of products."],
  ["5", "hasNextPage", "Whether there are more products to load."],
  ["9", "useQuery", "Retrieve the products from the API route."],
  ["23", "fetchMoreProducts", "Fetch more products when the user scrolls to the end of the list."],
]

```tsx title="src/admin/components/create-bundled-product.tsx" highlights={createBundledProductComponentHighlights2}
const [products, setProducts] = useState<HttpTypes.AdminProduct[]>([])
const productsLimit = 15
const [currentProductPage, setCurrentProductPage] = useState(0)
const [productsCount, setProductsCount] = useState(0)
const hasNextPage = useMemo(() => {
  return productsCount ? productsCount > productsLimit : true
}, 
[productsCount, productsLimit])
const queryClient = useQueryClient()
useQuery({
  queryKey: ["products"],
  queryFn: async () => {
    const { products, count } = await sdk.admin.product.list({
      limit: productsLimit,
      offset: currentProductPage * productsLimit,
    })
    setProductsCount(count)
    setProducts((prev) => [...prev, ...products])
    return products
  },
  enabled: hasNextPage,
})

const fetchMoreProducts = () => {
  if (!hasNextPage) {
    return
  }
  setCurrentProductPage(currentProductPage + 1)
}

// TODO add creation logic
```

You define new state variables to store the products, the current page of products, and the total number of products.

You also define a `hasNextPage` memoized variable to determine whether there are more products to load.

Then, you use the `useQuery` hook from Tanstack Query to retrieve the products from the Medusa server. You call the `sdk.admin.product.list` method to retrieve the products, passing it the `limit` and `offset` query parameters.

Lastly, you define a `fetchMoreProducts` function that increments the current page of products, which triggers retrieving more products. You'll call this function whenever the user scrolls to the end of the products list.

### Add Creation Logic to Form Component

Next, you'll define the logic to create the bundled product in the Medusa server once the user submits the form.

Replace the new `TODO` with the following:

export const createBundledProductComponentHighlights3 = [
  ["2", "createBundledProduct", "The mutation to create the bundled product."],
  ["13", "handleCreate", "The function that handles the form submission."],
]

```tsx title="src/admin/components/create-bundled-product.tsx" highlights={createBundledProductComponentHighlights3}
const { 
  mutateAsync: createBundledProduct, 
  isPending: isCreating,
} = useMutation({
  mutationFn: async (data: Record<string, any>) => {
    await sdk.client.fetch("/admin/bundled-products", {
      method: "POST",
      body: data,
    })
  },
})

const handleCreate = async () => {
  try {
    await createBundledProduct({
      title,
      product: {
        title,
        options: [
          {
            title: "Default",
            values: ["default"],
          },
        ],
        status: "published",
        variants: [
          {
            title,
            // You can set prices in the product's page
            prices: [],
            options: {
              Default: "default",
            },
            manage_inventory: false,
          },
        ],
      },
      items: items.map((item) => ({
        product_id: item.product_id,
        quantity: item.quantity,
      })),
    })
    setOpen(false)
    toast.success("Bundled product created successfully")
    queryClient.invalidateQueries({
      queryKey: ["bundled-products"],
    })
    setTitle("")
    setItems([{ product_id: undefined, quantity: 1 }])
  } catch (error) {
    toast.error("Failed to create bundled product")
  }
}
```

You first define a mutation using the `useMutation` hook from Tanstack Query. The mutation is used to create the bundled product by sending a `POST` request to the `/admin/bundled-products` API route.

Then, you define a `handleCreate` function that will be called when the user submits the form. In this function, you:

- Create the bundled product using the `createBundledProduct` mutation. You pass it the details of the bundle, its product, and its items.
    - Notice that you don't set the prices. You can use custom logic to set the prices, or [set the price](!user-guide!/products/variants#edit-product-variant-prices) from the bundle's associated product page.
- Close the modal and show a success message using the `toast` component from Medusa UI.

### Add Component for Each Item in the Form

Before adding the UI for the form, you'll add a component that renders the form fields for each item in the bundle. You'll later render this as part of the form UI.

In the same file, add the following after the `CreateBundledProduct` component:

export const createBundledProductComponentHighlights4 = [
  ["2", "item", "The item in the bundle."],
  ["6", "index", "The index of the item in the items array."],
  ["7", "setItems", "The state setter function to update the items."],
  ["11", "products", "The products retrieved from the Medusa server."],
  ["12", "fetchMoreProducts", "The function to fetch more products."],
  ["13", "hasNextPage", "Whether there are more products to load."],
  ["24", "observe", "Fetch more products when the user scrolls to the end of the list."],
]

```tsx title="src/admin/components/create-bundled-product.tsx" highlights={createBundledProductComponentHighlights4}
type BundledProductItemProps = {
  item: { 
    product_id: string | undefined, 
    quantity: number, 
  }
  index: number
  setItems: React.Dispatch<React.SetStateAction<{
    product_id: string | undefined;
    quantity: number;
  }[]>>
  products: HttpTypes.AdminProduct[] | undefined
  fetchMoreProducts: () => void
  hasNextPage: boolean
}

const BundledProductItem = ({ 
  item, 
  index, 
  setItems, 
  products, 
  fetchMoreProducts, 
  hasNextPage,
}: BundledProductItemProps) => {
  const observer = useRef(
    new IntersectionObserver(
      (entries) => {
        if (!hasNextPage) {
          return
        }
        const first = entries[0]
        if (first.isIntersecting) {
          fetchMoreProducts()
        }
      },
      { threshold: 1 }
    )
  )

  const lastOptionRef = useCallback(
    (node: HTMLDivElement) => {
      if (!hasNextPage) {
        return
      }
      if (observer.current) {
        observer.current.disconnect()
      }
      if (node) {
        observer.current.observe(node)
      }
    },
    [hasNextPage]
  )

  return (
    <div className="my-2">
      <Heading level={"h3"} className="mb-2">Item {index + 1}</Heading>
        <Select 
          value={item.product_id} 
          onValueChange={(value) => 
            setItems((items) => 
              items.map((item, i) => {
                return i === index 
                  ? { 
                      ...item, 
                      product_id: value, 
                    } 
                  : item
              })
            )
          }
        >
          <Select.Trigger>
            <Select.Value placeholder="Select Product" />
          </Select.Trigger>
          <Select.Content>
            {products?.map((product, productIndex) => (
              <Select.Item 
                key={product.id} 
                value={product.id} 
                ref={
                  productIndex === products.length - 1 
                    ? lastOptionRef 
                    : null
                }
              >
                {product.title}
              </Select.Item>
            ))}
          </Select.Content>
        </Select>
        <div className="flex items-center gap-x-2 [&_div]:flex-1">
          <Label>Quantity</Label>
          <Input
            type="number"
            placeholder="Quantity"
            className="w-full mt-1 rounded-md border border-gray-200 p-2"
            value={item.quantity}
            onChange={(e) => 
              setItems((items) => 
                items.map((item, i) => {
                  return i === index 
                    ? { ...item, quantity: parseInt(e.target.value) } 
                    : item
                })
              )
            }
          />
        </div>
    </div>
  )
}
```

You define a `BundledProductItem` component that accepts the following props:

- `item`: The item in the bundle as stored in the `items` state variable.
- `index`: The index of the item in the `items` state variable.
- `setItems`: The state setter function to update the `items` state variable.
- `products`: The list of products retrieved from the Medusa server.
- `fetchMoreProducts`: The function to fetch more products when the user scrolls to the end of the list.
- `hasNextPage`: A boolean indicating whether there are more products to load.

In the component, you render the selector field using the [Select](!ui!/components/select) component from Medusa UI. You show the products as options in the select, and update the product ID in the `items` state variable whenever the user selects a product.

You also observe the last option in the list of products using the [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API). This allows you to fetch more products when the user scrolls to the end of the list.

Finally, you render an input field for the quantity of the item in the bundle. You update the quantity in the `items` state variable whenever the user changes it.

### Add Form UI

Now that you have the component to render each item in the bundle, you can add the form UI in the `CreateBundledProduct` component.

In `CreateBundledProduct`, add the following `return` statement

```tsx title="src/admin/components/create-bundled-product.tsx"
return (
  <FocusModal open={open} onOpenChange={setOpen}>
    <FocusModal.Trigger asChild>
      <Button variant="primary">Create</Button>
    </FocusModal.Trigger>
    <FocusModal.Content>
      <FocusModal.Header>
        <div className="flex items-center justify-end gap-x-2">
          <Heading level={"h1"}>Create Bundled Product</Heading>
        </div>
      </FocusModal.Header>
      <FocusModal.Body>
        <div className="flex flex-1 flex-col items-center overflow-y-auto">
          <div className="mx-auto flex w-full max-w-[720px] flex-col gap-y-8 px-2 py-16">
            <div>
              <Label>Bundle Title</Label>
              <Input
                value={title}
                onChange={(e) => setTitle(e.target.value)}
              />
            </div>
            <div>
              <Heading level={"h2"}>Bundle Items</Heading>
              {items.map((item, index) => (
                <BundledProductItem
                  key={index}
                  item={item}
                  index={index}
                  setItems={setItems}
                  products={products}
                  fetchMoreProducts={fetchMoreProducts}
                  hasNextPage={hasNextPage}
                />
              ))}
              <Button
                variant="secondary"
                onClick={() =>
                  setItems([
                    ...items,
                    { product_id: undefined, quantity: 1 },
                  ])
                }
              >
                Add Item
              </Button>
            </div>
          </div>
        </div>
      </FocusModal.Body>
      <FocusModal.Footer>
        <div className="flex items-center justify-end gap-x-2">
          <Button variant="secondary" onClick={() => setOpen(false)}>
            Cancel
          </Button>
          <Button
            variant="primary"
            onClick={handleCreate}
            isLoading={isCreating}
          >
            Create Bundle
          </Button>
        </div>
      </FocusModal.Footer>
    </FocusModal.Content>
  </FocusModal>
)
```

You use the [FocusModal](!ui!/components/focus-modal) component from Medusa UI to show the form in a modal. The modal is opened when the "Create" button is clicked.

In the modal, you show an input field for the bundle title, and you show the list of bundle items using the `BundledProductItem` component. You also add a button to add new items to the bundle.

Finally, you show a "Create Bundle" button that calls the `handleCreate` function when clicked to create the bundle.

### Add Form to Bundled Products Page

Now that the form component is ready, you'll add it to the Bundled Products page. This will show the button to open the modal with the form.

In `src/admin/routes/bundled-products/page.tsx`, add the following import at the top of the file:

```tsx title="src/admin/routes/bundled-products/page.tsx"
import CreateBundledProduct from "../../components/create-bundled-product"
```

Then, in the `DataTable.Toolbar` component, add the `CreateBundledProduct` component after the heading:

```tsx title="src/admin/routes/bundled-products/page.tsx" highlights={[["3"]]}
<DataTable.Toolbar className="flex items-start justify-between gap-2 md:flex-row md:items-center">
  <Heading>Bundled Products</Heading>
  <CreateBundledProduct />
</DataTable.Toolbar>
```

This will show the button to open the form at the right side of the page's header.

### Test it Out

To test out the form, start the Medusa application by running the following command:

```bash npm2yarn
npm run dev
```

Then, open the Medusa Admin dashboard in your browser at `http://localhost:9000/app`, log in, and open the Bundled Products page.

<Note title="Tip">

Before creating the bundle, you may want to create the products in that bundle first. For example, if you're creating a "Camera Bundle", create "Camera" and "Camera Bag" products first.

</Note>

You'll see a new "Create" button at the top right. Click on it to open the modal with the form.

![Create button shown at the top right of the Bundled Products page](https://res.cloudinary.com/dza7lstvk/image/upload/v1745922803/Medusa%20Resources/Screenshot_2025-04-29_at_1.32.36_PM_yoo23i.png)

In the modal:

- Enter a title for the bundle. This title will also be used to create the associated product.
- For each item:
    - Select a product from the dropdown. You can scroll to the end of the list to load more products.
    - Enter a quantity for the item.
    - To add a new item, click on the "Add Item" button.
- Once you're done, click on the "Create Bundle" button to create the bundle.

![Create bundled product form](https://res.cloudinary.com/dza7lstvk/image/upload/v1745923393/Medusa%20Resources/Screenshot_2025-04-29_at_1.42.12_PM_mdyzsi.png)

After you create the bundle, the modal will close, and you can see the bundle in the table.

### Edit Associated Product

Once you have a bundle, you can go to its associated product page using the "View Product" link in the table.

In the associated product's page, you should:

- Set the sales channel that the product is available in to ensure it's available for sale.
- Set the shipping profile the product belongs to. This will allow customers to select the appropriate shipping option for the bundle during checkout.
- You can optionally edit other product details, such as the title, description, and images.

<Note>

Learn more about editing a product in the [User Guide](!user-guide!/products/edit)

</Note>

![Associated product page](https://res.cloudinary.com/dza7lstvk/image/upload/v1745923661/Medusa%20Resources/Screenshot_2025-04-29_at_1.46.52_PM_iuplxc.png)

---

## Step 9: Add Bundled Product to Cart

Now that you have bundled products, you need to support adding them to the cart.

In the storefront, when the customer adds the bundle to the cart, they'll select the variant for each item. For example, they can choose a "Black" or "Blue" camera bag.

So, you need to build a flow that adds the chosen product variants of the bundle's items to the cart. You'll add the variants with their default price and the quantity specified in the bundle.

You can customize this logic to fit your needs, such as adding the bundle as a single item in the cart with its total price, or setting custom price for each of the items.

To implement the add-to-cart logic for bundled products, you will:

- Create a workflow that implements the logic.
- Execute the workflow in an API route for storefronts.

### Create Workflow

The add-to-cart workflow for bundled products has the following steps:

<WorkflowDiagram
  workflow={{
    name: "addBundleToCartWorkflow",
    steps: [
      {
        name: "useQueryGraphStep",
        type: "step",
        description: "Retrieve the details of a bundle, its items, and their products and variants.",
        depth: 1,
        link: "/references/helper-steps/useQueryGraphStep"
      },
      {
        name: "prepareBundleCartDataStep",
        type: "step",
        description: "Validate and prepare the items to be added to the cart.",
        depth: 1,
      },
      {
        name: "addToCartWorkflow",
        type: "step",
        description: "Add the items in the bundle to the cart.",
        depth: 1,
        link: "/references/medusa-workflows/addToCartWorkflow"
      },
      {
        name: "useQueryGraphStep",
        type: "step",
        description: "Retrieve the details of the cart.",
        depth: 1,
        link: "/references/helper-steps/useQueryGraphStep"
      }
    ]
  }}
  hideLegend
/>

You only need to implement the second step, as the other steps are provided by Medusa's `@medusajs/medusa/core-flows` package.

#### a. prepareBundleCartDataStep

The second step of the workflow validates that the customer chose valid variants for each bundle item, and returns the items to be added to the cart.

To create the step, create the file `src/workflows/steps/prepare-bundle-cart-data.ts` with the following content:

export const prepareBundleCartDataStepHighlights = [
  ["12", "bundle", "The bundle to add to the cart."],
  ["15", "quantity", "The quantity of the bundle to add to the cart."],
  ["16", "items", "The selected variants for each item in the bundle."],
  ["15", "bundleItems", "Prepare the items to be added to the cart."],
  ["45", "variant_id", "The ID of the selected variant to add to the cart."],
  ["46", "quantity", "The quantity of the variant to add to the cart."],
  ["47", "metadata", "The metadata for the line item in the cart."],
  ["48", "bundle_id", "The ID of the bundle."],
  ["49", "quantity", "The quantity of the bundle added to the cart."],
]

```ts title="src/workflows/steps/prepare-bundle-cart-data.ts" highlights={prepareBundleCartDataStepHighlights} collapsibleLines="1-6" expandButtonLabel="Show Imports"
import { InferTypeOf, ProductDTO } from "@medusajs/framework/types"
import { Bundle } from "../../modules/bundled-product/models/bundle"
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { MedusaError } from "@medusajs/framework/utils"
import { BundleItem } from "../../modules/bundled-product/models/bundle-item"

type BundleItemWithProduct = InferTypeOf<typeof BundleItem> & {
  product: ProductDTO
}

export type PrepareBundleCartDataStepInput = {
  bundle: InferTypeOf<typeof Bundle> & {
    items: BundleItemWithProduct[]
  }
  quantity: number
  items: {
    item_id: string
    variant_id: string
  }[]
}

export const prepareBundleCartDataStep = createStep(
  "prepare-bundle-cart-data",
  async ({ bundle, quantity, items }: PrepareBundleCartDataStepInput) => {
    const bundleItems = bundle.items.map((item: BundleItemWithProduct) => {
      const selectedItem = items.find((i) => i.item_id === item.id)
      if (!selectedItem) {
        throw new MedusaError(
          MedusaError.Types.INVALID_DATA, 
          `No variant selected for bundle item ${item.id}`
        )
      }
      const variant = item.product.variants.find((v) => 
        v.id === selectedItem.variant_id
      )
      if (!variant) {
        throw new MedusaError(
          MedusaError.Types.INVALID_DATA, 
          `Variant ${
            selectedItem.variant_id
          } is invalid for bundle item ${item.id}`
        )
      }
      return {
        variant_id: selectedItem.variant_id,
        quantity: item.quantity * quantity,
        metadata: {
          bundle_id: bundle.id,
          quantity: quantity,
        },
      }
    })

    return new StepResponse(bundleItems)
  }  
)
```

The step receives as an input the bundle's details, the quantity of the bundle to add to the cart, and the selected variants for each item in the bundle.

In the step, you throw an error if an item in the bundle doesn't have a selected variant, or if the selected variant is invalid for that item.

Otherwise, you return an array of objects representing the items to be added to the cart. Each object has the following properties:

- `variant_id`: The ID of the selected variant to add to the cart.
- `quantity`: The quantity of the variant to add to the cart. This is calculated by multiplying the quantity of the item in the bundle with the quantity of the bundle to add to the cart.
- `metadata`: A line item in the cart has a `metadata` property that can be used to store custom key-value pairs. You store in it the ID of the bundle and its quantity that was added to the cart. This will be useful later when you want to retrieve the item's bundle.

#### Using Custom Prices

If you want to add the items to the cart with custom prices, you can modify the returned object in the loop to include a `unit_price` property. For example:

```ts highlights={[["4"]]}
return {
  variant_id: selectedItem.variant_id,
  quantity: item.quantity * quantity,
  unit_price: 100,
  metadata: {
    bundle_id: bundle.id,
    quantity: quantity,
  },
}
```

The item will then be added to the cart with that price. Note that the currency is based on the cart's currency.

For example, if the cart's currency is `usd`, then you're adding an item to the cart at the price `$100`.

#### b. Implement the Workflow

You can now create the workflow with the custom add-to-cart logic.

To create the workflow, create the file `src/workflows/add-bundle-to-cart.ts` with the following content:

export const addBundleToCartWorkflowHighlights = [
  ["28", "useQueryGraphStep", "Retrieve the bundle, its items, and their products and variants."],
  ["44", "prepareBundleCartDataStep", "Validate and prepare the items to be added to the cart."],
  ["50", "addToCartWorkflow", "Add the items in the bundle to the cart."],
  ["57", "useQueryGraphStep", "Retrieve the updated cart."],
]

```ts title="src/workflows/add-bundle-to-cart.ts" highlights={addBundleToCartWorkflowHighlights} collapsibleLines="1-14" expandButtonLabel="Show Imports"
import { 
  createWorkflow, 
  transform, 
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk"
import { 
  addToCartWorkflow, 
  useQueryGraphStep,
} from "@medusajs/medusa/core-flows"
import { 
  prepareBundleCartDataStep, 
  PrepareBundleCartDataStepInput,
} from "./steps/prepare-bundle-cart-data"

type AddBundleToCartWorkflowInput = {
  cart_id: string
  bundle_id: string
  quantity: number
  items: {
    item_id: string
    variant_id: string
  }[]
}

export const addBundleToCartWorkflow = createWorkflow(
  "add-bundle-to-cart",
  ({ cart_id, bundle_id, quantity, items }: AddBundleToCartWorkflowInput) => {
    const { data } = useQueryGraphStep({
      entity: "bundle",
      fields: [
        "id",
        "items.*",
        "items.product.*",
        "items.product.variants.*",
      ],
      filters: {
        id: bundle_id,
      },
      options: {
        throwIfKeyNotFound: true,
      },
    })
    
    const itemsToAdd = prepareBundleCartDataStep({
      bundle: data[0],
      quantity,
      items,
    } as unknown as PrepareBundleCartDataStepInput)

    addToCartWorkflow.runAsStep({
      input: {
        cart_id,
        items: itemsToAdd,
      },
    })

    const { data: updatedCarts } = useQueryGraphStep({
      entity: "cart",
      filters: { id: cart_id },
      fields: ["id", "items.*"],
    }).config({ name: "refetch-cart" })

    return new WorkflowResponse(updatedCarts[0])
  }
)
```

The workflow accepts as an input the cart's ID, the bundle's ID, the quantity of the bundle to add to the cart, and the selected variants for each item in the bundle.

In the workflow, you:

- Retrieve the bundle, its items, and their products and variants using the `useQueryGraphStep`.
- Validate and prepare the items to be added to the cart using the `prepareBundleCartDataStep`.
- Add the items to the cart using the `addToCartWorkflow`.
- Retrieve the updated cart using the `useQueryGraphStep`.

Finally, you return the updated cart.

### Create API Route

You'll now create the API route that exposes the workflow's functionalities to storefronts.

To create the API route, create the file `src/api/store/carts/[id]/line-item-bundles/route.ts` with the following content:

```ts title="src/api/store/carts/[id]/line-item-bundles/route.ts" collapsibleLines="1-6" expandButtonLabel="Show Imports"
import { MedusaRequest, MedusaResponse } from "@medusajs/framework/http"
import { z } from "zod"
import { 
  addBundleToCartWorkflow,
} from "../../../../../workflows/add-bundle-to-cart"

export const PostCartsBundledLineItemsSchema = z.object({
  bundle_id: z.string(),
  quantity: z.number().default(1),
  items: z.array(z.object({
    item_id: z.string(),
    variant_id: z.string(),
  })),
})

type PostCartsBundledLineItemsSchema = z.infer<
  typeof PostCartsBundledLineItemsSchema
>

export async function POST(
  req: MedusaRequest<PostCartsBundledLineItemsSchema>,
  res: MedusaResponse
) {
  const { result: cart } = await addBundleToCartWorkflow(req.scope)
    .run({
      input: {
        cart_id: req.params.id,
        bundle_id: req.validatedBody.bundle_id,
        quantity: req.validatedBody.quantity || 1,
        items: req.validatedBody.items,
      },
    })

  res.json({
    cart,
  })
}
```

You first define a Zod schema to validate the request body. The schema has the following properties:

- `bundle_id`: The ID of the bundle to add to the cart.
- `quantity`: The quantity of the bundle to add to the cart. This is optional and defaults to `1`.
- `items`: An array of objects representing the selected variants for each item in the bundle. Each object has the following properties:
    - `item_id`: The ID of the item in the bundle.
    - `variant_id`: The ID of the selected variant for that item.

Then, you export a `POST` route handler, which exposes a `POST` API route at `/store/carts/:id/line-item-bundles`.

In the route handler, you execute the `addBundleToCartWorkflow` workflow. Finally, you return the cart's details in the response.

### Add Validation Middleware

Lastly, you need to add the middleware that enforces the validation of incoming request bodies.

In `src/api/middlewares.ts`, add a new middleware object to the `routes` array:

```ts title="src/api/middlewares.ts"
// other imports...
import { 
  PostCartsBundledLineItemsSchema,
} from "./store/carts/[id]/line-item-bundles/route"

export default defineMiddlewares({
  routes: [
    // ...
    {
      matcher: "/store/carts/:id/line-item-bundles",
      methods: ["POST"],
      middlewares: [
        validateAndTransformBody(PostCartsBundledLineItemsSchema),
      ],
    },
  ],
})
```

This middleware will validate the request body against the `PostCartsBundledLineItemsSchema` schema before executing the route handler.

You can now use the API route to add bundles to the cart. You'll test it out in the upcoming sections when you customize the Next.js Starter Storefront.

---

## Step 10: Retrieve Bundled Product API Route

Before customizing the storefront, you'll create an API route to retrieve the details of a bundled product. This will be useful to show the bundle's details in the storefront.

To create the API route, create the file `src/api/store/bundle-products/[id]/route.ts` with the following content:

export const bundleProductsRouteHighlights = [
  ["8", "id", "The ID of the bundle, received as a path parameter."],
  ["10", "currency_code", "The currency code to retrieve the prices in."],
  ["10", "region_id", "The region ID to retrieve the prices in."],
  ["27", "context", "Pass the context necessary to retrieve correct prices."]
]

```ts title="src/api/store/bundle-products/[id]/route.ts" highlights={bundleProductsRouteHighlights} 
import { MedusaRequest, MedusaResponse } from "@medusajs/framework/http"
import { QueryContext } from "@medusajs/framework/utils"

export async function GET(
  req: MedusaRequest,
  res: MedusaResponse
) {
  const { id } = req.params
  const query = req.scope.resolve("query")
  const { currency_code, region_id } = req.query

  const { data } = await query.graph({
    entity: "bundle",
    fields: [
      "*", 
      "items.*", 
      "items.product.*", 
      "items.product.options.*",
      "items.product.options.values.*",
      "items.product.variants.*",
      "items.product.variants.calculated_price.*",
      "items.product.variants.options.*",
    ],
    filters: {
      id,
    },
    context: {
      items: {
        product: {
          variants: {
            calculated_price: QueryContext({
              region_id,
              currency_code,
            }),
          },
        },
      },
    },
  
  }, {
    throwIfKeyNotFound: true,
  })

  res.json({
    bundle_product: data[0],
  })
}
```

You export a `GET` route handler, which exposes a `GET` API route at `/store/bundle-products/:id`.

In the route handler, you resolve [Query](!docs!/learn/fundamentals/module-links/query) from the Medusa container.

Then, you use Query to retrieve the bundle with its items and their products, variants, and options. These are useful to display to the customer the options for each product to select from, which will result in selecting a variant for a bundle item.

To retrieve the correct price for each variant, you also pass a [Query Context](!docs!/learn/fundamentals/module-links/query-context) with the region ID and currency code that are passed as query parameters. This ensures that the prices are shown accurately to the customer.

<Note>

Refer to the [Get Product Variant Prices](../../../../commerce-modules/product/guides/price/page.mdx) guide to learn more about how to retrieve the prices of a product variant.

</Note>

Finally, you return the bundle's details in the response.

You'll use this API route next as you customize the storefront.

---

## Step 11: Show Bundled Product Details in Storefront

In this step, you'll customize the [Next.js Starter Storefront](../../../../nextjs-starter/page.mdx) you installed with the Medusa application to show a bundled product's items.

<Note title="Reminder" forceMultiline>

The Next.js Starter Storefront was installed in a separate directory from Medusa. The directory's name is `{your-project}-storefront`.

So, if your Medusa application's directory is `medusa-bundled-products`, you can find the storefront by going back to the parent directory and changing to the `medusa-bundled-products-storefront` directory:

```bash
cd ../medusa-bundled-products-storefront # change based on your project name
```

</Note>

### Add Function to Retrieve Bundled Product

You'll start by adding a server action function that retrieves the details of a bundled product.

In `src/lib/data/products.ts`, add the following at the end of the file:

export const getBundleProductHighlights = [
  ["1", "BundleProduct", "The type of the bundle product."],
  ["17", "getBundleProduct", "The function to retrieve the bundle product."],
]

```ts title="src/lib/data/products.ts" badgeLabel="Storefront" badgeColor="blue" highlights={getBundleProductHighlights}
export type BundleProduct = {
  id: string
  title: string
  product: {
    id: string
    thumbnail: string
    title: string
    handle: string
  }
  items: {
    id: string
    title: string
    product: HttpTypes.StoreProduct
  }[]
}

export const getBundleProduct = async (id: string, {
  currency_code,
  region_id,
}: {
  currency_code?: string
  region_id?: string
}) => {
  const headers = {
    ...(await getAuthHeaders()),
  }

  return sdk.client.fetch<{
    bundle_product: BundleProduct
  }>(`/store/bundle-products/${id}`, {
    method: "GET",
    headers,
    query: {
      currency_code,
      region_id,
    },
  })
}
```

You define a `BundledProduct` type that represents the structure of a bundled product.

Then, you define a `getBundleProduct` function that retrieves the bundle's details from the API route you created in the previous step.

### Retrieve Bundle with Product

Since a bundle is linked to a Medusa product, you can modify the request that retrieves the Medusa product to retrieve its associated bundle, if there's any.

By retrieving the bundle's details, you can check which Medusa product is a bundled product, then retrieve its full bundle details.

To retrieve a product's bundle details, first, change the signature of the `listProducts` function in `src/lib/data/products.ts` to the following:

export const listProductsHighlights = [
  ["13", "bundle", "Add the bundle to the product type."]
]

```ts title="src/lib/data/products.ts" badgeLabel="Storefront" badgeColor="blue" highlights={listProductsHighlights}
export const listProducts = async ({
  pageParam = 1,
  queryParams,
  countryCode,
  regionId,
}: {
  pageParam?: number
  queryParams?: HttpTypes.FindParams & HttpTypes.StoreProductParams
  countryCode?: string
  regionId?: string
}): Promise<{
  response: { products: (HttpTypes.StoreProduct & {
    bundle?: Omit<BundleProduct, "items">
  })[]; count: number }
  nextPage: number | null
  queryParams?: HttpTypes.FindParams & HttpTypes.StoreProductParams
}> => {
  // ...
}
```

You modify the response type to possibly include the bundle details (without the `items`) in each product.

Next, find the `sdk.client.fetch` call in `listProducts` and replace the type argument of `fetch` with the following:

export const fetchProductsHighlight = [
  ["3", "bundle", "Add the bundle to the product type."]
]

```ts title="src/lib/data/products.ts" badgeLabel="Storefront" badgeColor="blue" highlights={fetchProductsHighlight}
return sdk.client
  .fetch<{ products: (HttpTypes.StoreProduct & {
    bundle?: Omit<BundleProduct, "items">
  })[]; count: number }>(
    // ...
  )
```

This will ensure that the response from the API route is typed correctly.

Then, in `src/app/[countryCode]/(main)/products/[handle]/page.tsx`, add the following import at the top of the file:

```ts title="src/app/[countryCode]/(main)/products/[handle]/page.tsx" badgeLabel="Storefront" badgeColor="blue"
import { getBundleProduct } from "@lib/data/products"
```

After that, in the `ProductPage` component in the same file, find the declaration of `pricedProduct` and update the query parameters passed to `listProducts`:

```ts title="src/app/[countryCode]/(main)/products/[handle]/page.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={[["5"]]}
const pricedProduct = await listProducts({
  countryCode: params.countryCode,
  queryParams: { 
    handle: params.handle, 
    fields: "*bundle",
  },
}).then(({ response }) => response.products[0])
```

You add the `fields` query parameter an set it to `*bundle`. This will ensure that the bundle details are included in the retrieved product objects.

Next, after the `if` condition that checks if `pricedProduct` isn't `undefined`, add the following code:

```ts title="src/app/[countryCode]/(main)/products/[handle]/page.tsx" badgeLabel="Storefront" badgeColor="blue"
const bundleProduct = pricedProduct.bundle ? 
    await getBundleProduct(pricedProduct.bundle.id, {
      currency_code: region.currency_code,
      region_id: region.id,
    }) : null
```

This will retrieve the full bundled product details if the product is associated with a bundle.

### Add Bundle to Cart Function

Next, you'll add a function that adds the bundle to the cart using the API route you created in the previous step.

In `src/lib/data/cart.ts`, add the following function at the end of the file:

```ts title="src/lib/data/cart.ts" badgeLabel="Storefront" badgeColor="blue"
export async function addBundleToCart({
  bundleId,
  quantity,
  countryCode,
  items,
}: {
  bundleId: string
  quantity: number
  countryCode: string
  items: {
    item_id: string
    variant_id: string
  }[]
}) {
  if (!bundleId) {
    throw new Error("Missing bundle ID when adding to cart")
  }

  const cart = await getOrSetCart(countryCode)

  if (!cart) {
    throw new Error("Error retrieving or creating cart")
  }

  const headers = {
    ...(await getAuthHeaders()),
  }

  await sdk.client.fetch<HttpTypes.StoreCartResponse>(
    `/store/carts/${cart.id}/line-item-bundles`,
  {
    method: "POST",
    body: {
      bundle_id: bundleId,
      quantity,
      items,
    },
    headers,
  })
    .then(async () => {
      const cartCacheTag = await getCacheTag("carts")
      revalidateTag(cartCacheTag)

      const fulfillmentCacheTag = await getCacheTag("fulfillment")
      revalidateTag(fulfillmentCacheTag)
    })
    .catch(medusaError)
}
```

You define the `addBundleToCart` function that sends a `POST` request to the API route you created in the previous step.

The request body includes the bundle ID, quantity, and selected variants for each item in the bundle.

### Show Bundle Item Selection Actions

You'll now add a component that shows for bundled product their items and allow the customer to select the product variant for each item, then add it to the cart.

#### a. Add Bundle Actions Component

To create the component, create the file `src/modules/products/components/bundle-actions/index.tsx` with the following content:

export const bundleActionsComponentHighlights = [
  ["30", "productOptions", "The selected options for each product in the bundle."],
  ["33", "isAdding", "Whether the bundle is being added to the cart."],
  ["34", "countryCode", "The country code from the URL parameters."],
]

```tsx title="src/modules/products/components/bundle-actions/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={bundleActionsComponentHighlights} collapsibleLines="1-13" expandButtonLabel="Show Imports"
"use client"

import { addBundleToCart } from "@lib/data/cart"
import { HttpTypes } from "@medusajs/types"
import { Button } from "@medusajs/ui"
import OptionSelect from "@modules/products/components/product-actions/option-select"
import { BundleProduct } from "@lib/data/products"
import { isEqual } from "lodash"
import { useParams } from "next/navigation"
import { useEffect, useMemo, useState } from "react"
import ProductPrice from "../product-price"
import Thumbnail from "../thumbnail"

type BundleActionsProps = {
  bundle: BundleProduct
}

const optionsAsKeymap = (
  variantOptions: HttpTypes.StoreProductVariant["options"]
) => {
  return variantOptions?.reduce((acc: Record<string, string>, varopt: any) => {
    acc[varopt.option_id] = varopt.value
    return acc
  }, {})
}

export default function BundleActions({
  bundle,
}: BundleActionsProps) {
  const [productOptions, setProductOptions] = useState<
    Record<string, Record<string, string>>
  >({})
  const [isAdding, setIsAdding] = useState(false)
  const countryCode = useParams().countryCode as string

  // TODO retrieve and set selected variants and options
}
```

First, you define an `optionsAsKeymap` function that converts the product variant options into a key-value map. This is useful to later compare the selected options with the available options.

Then, you define the `BundleActions` component that accepts a `bundle` prop. In the component, you define:

- `productOptions`: A state variable that stores the selected options for each product in the bundle. The key is the product ID, and the value is a key-value map of the selected options.
- `isAdding`: A state variable that indicates whether the bundle is being added to the cart.
- `countryCode`: The country code from the URL parameters.

#### b. Selected Variants and Options Logic

Next, you'll add the logic to retrieve and set the selected variants and options for each product in the bundle.

In `BundleActions`, replace the `TODO` with the following:

export const bundleActionsComponentHighlights2 = [
  ["2", "useEffect", "Hook to set the initial selected options."],
  ["15", "selectedVariants", "Set the selected variants for each product."],
  ["26", "setOptionValue", "Function to update the selected options."],
  ["36", "allVariantsSelected", "Whether all items have selected variants."],
]

```tsx title="src/modules/products/components/bundle-actions/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={bundleActionsComponentHighlights2}
// For each product, if it has only 1 variant, preselect it
useEffect(() => {
  const initialOptions: Record<string, Record<string, string>> = {}
  bundle.items.forEach((item) => {
    if (item.product.variants?.length === 1) {
      const variantOptions = optionsAsKeymap(item.product.variants[0].options)
      initialOptions[item.product.id] = variantOptions ?? {}
    } else {
      initialOptions[item.product.id] = {}
    }
  })
  setProductOptions(initialOptions)
}, [bundle.items])

const selectedVariants = useMemo(() => {
  return bundle.items.map((item) => {
    if (!item.product.variants || item.product.variants.length === 0) {return undefined}

    return item.product.variants.find((v) => {
      const variantOptions = optionsAsKeymap(v.options)
      return isEqual(variantOptions, productOptions[item.product.id])
    })
  })
}, [bundle.items, productOptions])

const setOptionValue = (productId: string, optionId: string, value: string) => {
  setProductOptions((prev) => ({
    ...prev,
    [productId]: {
      ...prev[productId],
      [optionId]: value,
    },
  }))
}

const allVariantsSelected = useMemo(() => {
  return selectedVariants.every((v) => v !== undefined)
}, [selectedVariants])

// TODO handle add to cart
```

In the `useEffect` hook, you check if each product in the bundle has only one variant. If it does, you preselect that variant's options. This ensures the customer doesn't need to select the options if there's only one variant available.

Then, you define a `selectedVariants` variable that stores the selected variants for each product in the bundle. A selected variant is inferred if all options of a product are selected.

You also define a `setOptionValue` function that updates the selected options for a product. You'll trigger this function when the customer selects an option.

Finally, you define an `allVariantsSelected` variable that indicates whether all variants are selected.

#### c. Handle Add to Cart

Next, you'll add a function that is triggered when the add-to-cart button is clicked.

Replace the `TODO` in the `BundleActions` component with the following code:

```tsx title="src/modules/products/components/bundle-actions/index.tsx" badgeLabel="Storefront" badgeColor="blue"
const handleAddToCart = async () => {
  if (!allVariantsSelected) {return}

  setIsAdding(true)
  await addBundleToCart({
    bundleId: bundle.id,
    quantity: 1,
    countryCode,
    items: bundle.items.map((item, index) => ({
      item_id: item.id,
      variant_id: selectedVariants[index]?.id ?? "",
    })),
  })
  setIsAdding(false)
}
```

The `handleAddToCart` function adds the bundle to the cart if all variants have been selected. It uses the `addBundleToCart` function you created in the previous step.

#### d. Customize the ProductPrice Component

Before you render the component in `BundleActions`, you'll make a small adjustment to the `ProductPrice` component to allow passing a CSS class.

In `src/modules/products/components/product-price/index.tsx`, add a `className` prop to the `ProductPrice` component:

```tsx title="src/modules/products/components/product-price/index.tsx" badgeLabel="Storefront" badgeColor="blue"
export default function ProductPrice({
  // ...
  className,
}: {
  // ...
  className?: string
}) {
  // ...
}
```

Then, in the `return` statement, pass the `className` prop in the classes of the first `span` child of the wrapper `div`:

```tsx title="src/modules/products/components/product-price/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={[["5"]]}
<div className="flex flex-col text-ui-fg-base">
  <span
    className={clx("text-xl-semi", {
      "text-ui-fg-interactive": selectedPrice.price_type === "sale",
    }, className)}
  >
   {/* ... */}
  </span>
</div>
```

#### e. Render the Component

Finally, you'll render the component that shows the bundle's items and allows the customer to select the product variant for each item.

Add the following `return` statement to the `BundleActions` component:

```tsx title="src/modules/products/components/bundle-actions/index.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div className="flex flex-col gap-y-6 max-w-2xl mx-auto w-full">
    <h2 className="text-2xl">Items in Bundle</h2>
    <div className="grid gap-6">
      {bundle.items.map((item, index) => (
        <div 
          key={item.product.id} 
          className="rounded-lg p-6 shadow-elevation-card-rest hover:shadow-elevation-card-hover transition-shadow bg-white"
        >
          <div className="flex items-start gap-4">
            <Thumbnail
              thumbnail={item.product.thumbnail}
              className="w-24 h-24 rounded-md"
              size="square"
              images={[]}
            />
            <div>
              <h3 className="text-lg">{item.product.title}</h3>
              <ProductPrice
                product={item.product}
                variant={selectedVariants[index]}
                className="!text-sm mt-2 text-ui-fg-muted"
              />
            </div>
          </div>

          {(item.product.variants?.length ?? 0) > 1 && (
            <div className="space-y-4 mt-4">
              {(item.product.options || []).map((option) => (
                <div key={option.id}>
                  <OptionSelect
                    option={option}
                    current={productOptions[item.product.id]?.[option.id]}
                    updateOption={(optionId, value) =>
                      setOptionValue(item.product.id, optionId, value)
                    }
                    title={option.title ?? ""}
                    disabled={isAdding}
                  />
                </div>
              ))}
            </div>
          )}
        </div>
      ))}
    </div>

    <Button
      onClick={handleAddToCart}
      disabled={!allVariantsSelected || isAdding}
      variant="primary"
      className="w-full h-10"
      isLoading={isAdding}
    >
      {!allVariantsSelected ? "Select all variants" : "Add bundle to cart"}
    </Button>
  </div>
)
```

You show the bundle's items in cards. For each item, you show the product's thumbnail, title, and price.

If a product has multiple options, you show the options as buttons that the customer can select from.

Finally, you show an add-to-cart button that is disabled if not all items have selected variants, or if the bundle is being added to the cart.

### Use BundleActions Component in Product Page

You'll show the `BundleActions` component in the product page if the product is a bundled product.

First, in `src/modules/products/templates/product-actions-wrapper/index.tsx` add the following imports at the top of the file:

```tsx title="src/modules/products/templates/product-actions-wrapper/index.tsx" badgeLabel="Storefront" badgeColor="blue"
import { BundleProduct } from "@lib/data/products"
import BundleActions from "@modules/products/components/bundle-actions"
```

Then, add a `bundle` prop to the `ProductActionsWrapper` component:

```tsx title="src/modules/products/templates/product-actions-wrapper/index.tsx" badgeLabel="Storefront" badgeColor="blue"
export default async function ProductActionsWrapper({
  // ...
  bundle,
}: {
  // ...
  bundle?: BundleProduct
}) {
  // ...
}
```

Finally, add the following before the `ProductActionsWrapper` component's `return` statement:

```tsx title="src/modules/products/templates/product-actions-wrapper/index.tsx" badgeLabel="Storefront" badgeColor="blue"
if (bundle) {
  return <BundleActions bundle={bundle} />
}
```

This will show the `BundleActions` component if the `bundle` prop is set.

Next, you need to pass the `bundle` prop to the `ProductActionsWrapper` component.

In `src/modules/products/templates/index.tsx`, add the following import at the top of the file:

```tsx title="src/modules/products/templates/index.tsx" badgeLabel="Storefront" badgeColor="blue"
import { BundleProduct } from "@lib/data/products"
```

And pass the `bundle` prop to the `ProductTemplate` component:

```tsx title="src/modules/products/templates/index.tsx" badgeLabel="Storefront" badgeColor="blue"
type ProductTemplateProps = {
  // ...
  bundle?: BundleProduct
}

const ProductTemplate: React.FC<ProductTemplateProps> = ({
  // ...
  bundle,
}) => {
  // ...
}
```

Then, in the `ProductTemplate` component's `return` statement, find the `ProductActionsWrapper` component and pass the `bundle` prop to it:

```tsx title="src/modules/products/templates/index.tsx" badgeLabel="Storefront" badgeColor="blue"
<ProductActionsWrapper
  // ...
  bundle={bundle}
/>
```

Lastly, you need to pass the `bundle` prop to the `ProductTemplate` component.

In `src/app/[countryCode]/(main)/products/[handle]/page.tsx`, add the `bundle` prop to `ProductTemplate` in the `ProductPage`'s `return` statement:

```tsx title="src/app/[countryCode]/(main)/products/[handle]/page.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <ProductTemplate
    // ...
    bundle={bundleProduct?.bundle_product}
  />
)
```

You pass the bundle using the `bundleProduct` variable you declared earlier.

### Test it Out

To test it out, start the Medusa application by running the following command in the Medusa application's directory:

```bash npm2yarn badgeLabel="Medusa application" badgeColor="green"
npm run dev
```

Then, start the Next.js Starter Storefront by running the following command in the storefront's directory:

```bash npm2yarn badgeLabel="Storefront" badgeColor="blue"
npm run dev
```

Next, open the storefront in your browser at `http://localhost:8000`, click on Menu at the top right, then choose Store from the menu.

This will open the product catalogue page, showing the product associated with your bundled product.

<Note title="Can't see the bundled product?" forceMultiline>

If you can't see the product associated with your bundled product, make sure you've added it to the default sales channel (or the sales channel you use in your storefront), as explained in the [Edit Associated Product](#edit-associated-product) section.

The items in the bundle must also be added to the same sales channel.

</Note>

![Product catalogue page with the bundled product showing](https://res.cloudinary.com/dza7lstvk/image/upload/v1745926664/Medusa%20Resources/Screenshot_2025-04-29_at_2.37.22_PM_ktk4e5.png)

If you click on the bundled product, you can see in its details page the items in the bundle.

![Bundled products detail page showing the items](https://res.cloudinary.com/dza7lstvk/image/upload/v1745926778/Medusa%20Resources/Screenshot_2025-04-29_at_2.39.16_PM_mskh01.png)

Once you select the necessary options for all products in the bundle, the "Add to cart" button will be enabled. You can click on it to add the bundle's items to the cart.

![Cart with the bundled items in it](https://res.cloudinary.com/dza7lstvk/image/upload/v1745929244/Medusa%20Resources/Screenshot_2025-04-29_at_3.20.27_PM_qnbdds.png)

You can then place an order with the bundled items. Then, on the Medusa Admin dashboard, you can fulfill and process the items separately.

![Example of fulfilling one item in the bundle](https://res.cloudinary.com/dza7lstvk/image/upload/v1745929701/Medusa%20Resources/Screenshot_2025-04-29_at_3.22.02_PM_nvrvvz.png)

---

## Step 12: Remove Bundle from Cart

The last functionality you'll implement is the ability to remove a bundled product from the cart. When a customer chooses to remove an item in the cart that's part of a bundle, you should remove all items in the bundle from the cart.

To implement this, you need:

- A workflow that implements the logic to remove a bundle's items from the cart.
- An API route that exposes the workflow's functionality to storefronts.
- A function in the storefront that calls the API route to remove the bundle from the cart.

### Create Remove Bundle from Cart Workflow

You'll start by creating a workflow that implements the logic to remove a bundle's items from the cart.

The workflow has the following steps:

<WorkflowDiagram
  workflow={{
    name: "removeBundleFromCartWorkflow",
    steps: [
      {
        name: "useQueryGraphStep",
        type: "step",
        description: "Retrieve the details of the cart and its items.",
        depth: 1,
        link: "/references/helper-steps/useQueryGraphStep"
      },
      {
        name: "deleteLineItemsWorkflow",
        type: "workflow",
        description: "Remove the items in the bundle from the cart.",
        depth: 1,
        link: "/references/medusa-workflows/deleteLineItemsWorkflow"
      },
      {
        name: "useQueryGraphStep",
        type: "step",
        description: "Retrieve the updated cart.",
        depth: 1,
        link: "/references/helper-steps/useQueryGraphStep"
      }
    ]
  }}
  hideLegend
/>

Medusa provides all these steps and workflows in its `@medusajs/medusa/core-flows` package. So, you can create the workflow right away.

Create the file `src/workflows/remove-bundle-from-cart.ts` with the following content:

export const removeBundleFromCartWorkflowHighlights = [
  ["19", "useQueryGraphStep", "Retrieve the details of the cart and its items."],
  ["33", "transform", "Prepare the IDs of the items to remove."],
  ["42", "deleteLineItemsWorkflow", "Remove the items in the bundle from the cart."],
  ["50", "useQueryGraphStep", "Retrieve the updated cart."],
]

```ts title="src/workflows/remove-bundle-from-cart.ts" collapsibleLines="1-10" expandButtonLabel="Show Imports" highlights={removeBundleFromCartWorkflowHighlights}
import { 
  createWorkflow, 
  transform, 
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk"
import { 
  deleteLineItemsWorkflow, 
  useQueryGraphStep,
} from "@medusajs/medusa/core-flows"

type RemoveBundleFromCartWorkflowInput = {
  bundle_id: string
  cart_id: string
}

export const removeBundleFromCartWorkflow = createWorkflow(
  "remove-bundle-from-cart",
  ({ bundle_id, cart_id }: RemoveBundleFromCartWorkflowInput) => {
    const { data: carts } = useQueryGraphStep({
      entity: "cart",
      fields: [
        "*",
        "items.*",
      ],
      filters: {
        id: cart_id,
      },
      options: {
        throwIfKeyNotFound: true,
      },
    })

    const itemsToRemove = transform({
      cart: carts[0],
      bundle_id,
    }, (data) => {
      return data.cart.items.filter((item) => {
        return item?.metadata?.bundle_id === data.bundle_id
      }).map((item) => item!.id)
    })

    deleteLineItemsWorkflow.runAsStep({
      input: {
        cart_id,
        ids: itemsToRemove,
      },
    })

    // retrieve cart again
    const { data: updatedCarts } = useQueryGraphStep({
      entity: "cart",
      fields: [
        "*",
        "items.*",
      ],
      filters: {
        id: cart_id,
      },
    }).config({ name: "retrieve-cart" })
    
    return new WorkflowResponse(updatedCarts[0])
  }
)
```

The workflow accepts as an input the bundle's ID and the cart's ID.

In the workflow, you:

- Retrieve the cart and its items using the `useQueryGraphStep`.
- Use `transform` to filter the items in the cart and return only the IDs of the items that belong to the bundle.
- Remove the items from the cart using the `deleteLineItemsWorkflow`.
- Retrieve the updated cart using the `useQueryGraphStep`.

Finally, you return the updated cart.

### Create API Route

Next, you'll create the API route that exposes the workflow's functionality to storefronts.

Create the file `src/api/store/carts/[id]/line-item-bundles/[bundle_id]/route.ts` with the following content:

```ts title="src/api/store/carts/[id]/line-item-bundles/[bundle_id]/route.ts"
import { MedusaRequest, MedusaResponse } from "@medusajs/framework/http"
import { 
  removeBundleFromCartWorkflow,
} from "../../../../../../workflows/remove-bundle-from-cart"

export async function DELETE(
  req: MedusaRequest,
  res: MedusaResponse
) {
  const { result: cart } = await removeBundleFromCartWorkflow(req.scope)
    .run({
      input: {
        cart_id: req.params.id,
        bundle_id: req.params.bundle_id,
      },
    })

  res.json({
    cart,
  })
}
```

You export a `DELETE` route handler, which exposes a `DELETE` API route at `/store/carts/:id/line-item-bundles/:bundle_id`.

In the route handler, you execute the `removeBundleFromCartWorkflow` workflow to delete the bundle's items from the cart.

Finally, you return the updated cart in the response.

### Add Remove Bundle from Cart in Storefront

You'll now customize the storefront to add a button that removes the bundle from the cart.

Start by adding the following function at the end of `src/lib/data/cart.ts`:

```ts title="src/lib/data/cart.ts" badgeLabel="Storefront" badgeColor="blue"
export async function removeBundleFromCart(bundleId: string) {
  const cartId = await getCartId()
  const headers = {
    ...(await getAuthHeaders()),
  }
 
  await sdk.client.fetch<HttpTypes.StoreCartResponse>(
    `/store/carts/${cartId}/line-item-bundles/${bundleId}`, 
    {
      method: "DELETE",
      headers,
    }
  )
    .then(async () => {
      const cartCacheTag = await getCacheTag("carts")
      revalidateTag(cartCacheTag)

      const fulfillmentCacheTag = await getCacheTag("fulfillment")
      revalidateTag(fulfillmentCacheTag)
    })
    .catch(medusaError)
}
```

You define the `removeBundleFromCart` function that sends a `DELETE` request to the API route you created in the previous step.

Next, you'll update the delete button used in the cart UI to call the `removeBundleFromCart` function when removing a bundle item from the cart.

In `src/modules/common/components/delete-button/index.tsx`, add the following import at the top of the file:

```tsx title="src/modules/common/components/delete-button/index.tsx" badgeLabel="Storefront" badgeColor="blue"
import { removeBundleFromCart } from "@lib/data/cart"
```

Then, add a `bundle_id` prop to the `DeleteButton` component:

```tsx title="src/modules/common/components/delete-button/index.tsx" badgeLabel="Storefront" badgeColor="blue"
const DeleteButton = ({
  // ...
  bundle_id,
}: {
  // ...
  bundle_id?: string
}) => {
  // ...
}
```

Finally, replace the `handleDelete` function in the `DeleteButton` component with the following:

```tsx title="src/modules/common/components/delete-button/index.tsx" badgeLabel="Storefront" badgeColor="blue"
const handleDelete = async (id: string) => {
  setIsDeleting(true)
  if (bundle_id) {
    await removeBundleFromCart(bundle_id).catch((err) => {
      setIsDeleting(false)
    })
  } else {
    await deleteLineItem(id).catch((err) => {
      setIsDeleting(false)
    })
  }
}
```

If the `bundle_id` prop is set, the `handleDelete` function calls the `removeBundleFromCart` function. Otherwise, it calls the default `deleteLineItem` function.

Next, you'll update the components using the `DeleteButton` component to pass the `bundle_id` prop.

In `src/modules/cart/components/item/index.tsx`, find the `DeleteButton` component in the `return` statement and replace it with the following:

```tsx title="src/modules/cart/components/item/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={[["4"]]}
<DeleteButton 
  id={item.id} 
  data-testid="product-delete-button" 
  bundle_id={item.metadata?.bundle_id as string}
>
  {item.metadata?.bundle_id !== undefined ? "Remove bundle" : "Remove"}
</DeleteButton>
```

You pass the `bundle_id` prop to the `DeleteButton` component, which is set to the item's metadata. You also change the text based on whether the item is in a bundle.

Then, in `src/modules/layout/components/cart-dropdown/index.tsx`, find the `DeleteButton` component in the `return` statement and replace it with the following:

```tsx title="src/modules/layout/components/cart-dropdown/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={[["5"]]}
<DeleteButton
  id={item.id}
  className="mt-1"
  data-testid="cart-item-remove-button"
  bundle_id={item.metadata?.bundle_id as string}
>
  {item.metadata?.bundle_id !== undefined ? "Remove bundle" : "Remove"}
</DeleteButton>
```

Similarly, you pass the `bundle_id` prop to the `DeleteButton` component and change the text based on whether the item is in a bundle.

### Test it Out

To test it out, start the Medusa application and the Next.js Starter Storefront as you did in the previous step.

Then, open the storefront in your browser at `http://localhost:8000`. Given you've already added a bundled product to the cart, you can now see a "Remove bundle" button next to the bundled product in the cart.

![Cart with the Remove bundle button showing for bundle items](https://res.cloudinary.com/dza7lstvk/image/upload/v1746011200/Medusa%20Resources/Screenshot_2025-04-30_at_2.06.02_PM_cgtg45.png)

If you click on the "Remove bundle" button for any of the bundle's items, all items in the bundle will be removed from the cart.

---

## Next Steps

Now that you have a working bundled product feature, you can customize it further to fit your use case:

- Add API routes to update the bundled product and its items in the cart.
- Add more CRUD management features to the Bundled Products page in the Medusa Admin.
- Customize the Next.js Starter Storefront to show the bundled products together in the cart, rather than seperately.
- Use custom logic to set the price of the bundled product.

If you're new to Medusa, check out the [main documentation](!docs!/learn), where you'll get a more in-depth learning of all the concepts you've used in this guide and more.

To learn more about the commerce features that Medusa provides, check out Medusa's [Commerce Modules](../../../../commerce-modules/page.mdx).
