---
sidebar_label: "Phone Authentication"
tags:
    - name: auth
      label: "Implement Phone Authentication"
    - name: customer
      label: "Implement Phone Authentication"
    - server
    - tutorial
products:
  - customer
  - auth
---

import { Github, PlaySolid } from "@medusajs/icons"
import { Prerequisites, WorkflowDiagram, CardList } from "docs-ui"

export const metadata = {
  title: `Implement Phone Authentication and Integrate Twilio SMS`,
}

# {metadata.title}

In this tutorial, you will learn how to implement phone number authentication in your Medusa application.

When you install a Medusa application, you get a fully-fledged commerce platform with a Framework for customization. The Medusa application's commerce features are built around [Commerce Modules](../../../commerce-modules/page.mdx), which are available out-of-the-box. These features include authentication with custom providers and for custom user or actor types.

In this tutorial, you'll learn how to implement a custom authentication provider that allows customers to log in with their phone number. You'll also integrate [Twilio](https://www.twilio.com/en-us/messaging/channels/sms) to send SMS messages to those customers with the one-time password (OTP) for authentication.

<Note>

Twilio is just one option to deliver the OTP to the customer. You can integrate a different SMS provider or use a different method to send OTPs.

</Note>

## Summary

By following this tutorial, you will learn how to:

- Install and set up Medusa.
- Implement a custom phone authentication provider.
- Integrate Twilio to send OTPs by SMS.
- Customize the Next.js Starter Storefront to allow customers to log in with their phone numbers.

You can follow this tutorial whether you're new to Medusa or an advanced Medusa developer.

![Diagram showcasing the phone authentication flow](https://res.cloudinary.com/dza7lstvk/image/upload/v1747744941/Medusa%20Resources/phone-auth-overview_bt5yrp.jpg)

<Note>

While this tutorial focuses on supporting phone authentication for customers, you can use the authentication provider for any actor type, such as admin user or vendor. [At the end of this tutorial](#next-steps), you'll learn how to authenticate other actor types.

</Note>

<CardList items={[
  {
    href: "https://github.com/medusajs/examples/tree/main/phone-auth",
    title: "Phone Authentication Repository",
    text: "Find the full code for this guide in this repository.",
    icon: Github,
  },
  {
    href: "https://res.cloudinary.com/dza7lstvk/raw/upload/v1747745832/OpenApi/Phone_Auth_g4xsqv.yaml",
    title: "OpenApi Specs for Postman",
    text: "Import this OpenApi Specs file into tools like Postman.",
    icon: PlaySolid,
  },
]} />

---

## Step 1: Install a Medusa Application

<Prerequisites items={[
  {
    text: "Node.js v20+",
    link: "https://nodejs.org/en/download"
  },
  {
    text: "Git CLI tool",
    link: "https://git-scm.com/downloads"
  },
  {
    text: "PostgreSQL",
    link: "https://www.postgresql.org/download/"
  }
]} />

Start by installing the Medusa application on your machine with the following command:

```bash
npx create-medusa-app@latest
```

You'll first be asked for the project's name. Then, when asked whether you want to install the [Next.js Starter Storefront](../../../nextjs-starter/page.mdx), choose Yes.

Afterward, the installation process will start, which will install the Medusa application in a directory with your project's name, and the Next.js Starter Storefront in a separate directory with the `{project-name}-storefront` name.

<Note title="Why is the storefront installed separately?">

The Medusa application is composed of a headless Node.js server and an admin dashboard. The storefront is installed or custom-built separately and connects to the Medusa application through its REST endpoints, called [API routes](!docs!/learn/fundamentals/api-routes). Learn more in [Medusa's Architecture documentation](!docs!/learn/introduction/architecture).

</Note>

Once the installation finishes successfully, the Medusa Admin dashboard will open with a form to create a new user. Enter the user's credentials and submit the form. Afterward, you can log in with the new user and explore the dashboard.

<Note title="Ran into Errors?">

Check out the [troubleshooting guides](../../../troubleshooting/create-medusa-app-errors/page.mdx) for help.

</Note>

---

## Step 2: Implement Phone Authentication Module Provider

In Medusa, you integrate custom authentication providers by creating an [Authentication Module Provider](../../../commerce-modules/auth/auth-providers/page.mdx). Then, you can use that provider to authenticate users using custom logic.

In this step, you'll create a Phone Authentication Module Provider that allows users to log in with their phone numbers and an OTP. Later, you'll integrate Twilio to send the OTPs to the users, and customize the storefront to allow customers to log in with their phone numbers.

<Note title="Good to Know">

An Authentication Module Provider doesn't need to handle storing and managing specific user details, such as creating customers or admin users. Instead, it only focuses on the logic of authenticating a type of user using custom logic or integration. You can learn more in the [Auth Module](../../../commerce-modules/auth/page.mdx) documentation.

</Note>

### Prerequisite: Install jsonwebtoken

In the Phone Authentication Module Provider, you'll use the `jsonwebtoken` package to sign and verify the OTPs.

To install the package, run the following command in the Medusa application directory:

```bash npm2yarn
npm install jsonwebtoken
npm install @types/jsonwebtoken --save-dev
```

### a. Create Module Directory

Modules are created under the `src/modules` directory. So, start by creating the directory `src/modules/phone-auth`.

### b. Create Auth Module Provider Service

A module has a service that contains its logic. For Authentication Module Providers, the service implements the logic to authenticate users.

To create the service of the Phone Authentication Module Provider, create the file `src/modules/phone-auth/service.ts` with the following content:

export const phoneAuthServiceHighlights = [
  ["10", "logger", "Resolve Logger class to log debug messages."],
  ["11", "event_bus", "Resolve Event Module's service to emit events."],
  ["15", "jwtSecret", "JWT secret to sign and verify OTPs."],
  ["19", "DISPLAY_NAME", "Human-readable name for the provider."],
  ["20", "identifier", "Unique identifier for the provider."],
]

```ts title="src/modules/phone-auth/service.ts" highlights={phoneAuthServiceHighlights}
import { 
  AbstractAuthModuleProvider, 
  AbstractEventBusModuleService, 
} from "@medusajs/framework/utils"
import { 
  Logger, 
} from "@medusajs/types"

type InjectedDependencies = {
  logger: Logger
  event_bus: AbstractEventBusModuleService
}

type Options = {
  jwtSecret: string
}

class PhoneAuthService extends AbstractAuthModuleProvider {
  static DISPLAY_NAME = "Phone Auth"
  static identifier = "phone-auth"
  private options: Options
  private logger: Logger
  private event_bus: AbstractEventBusModuleService

  constructor(container: InjectedDependencies, options: Options) {
    // @ts-ignore
    super(...arguments)

    this.options = options
    this.logger = container.logger
    this.event_bus = container.event_bus
  }
}

export default PhoneAuthService
```

An Authentication Module Provider's service must extend the `AbstractAuthModuleProvider` class. You'll get a type error about implementing the abstract methods of that class, which you'll add in the next steps.

An Authentication Module Provider must also have the following static properties:

- `identifier`: A unique identifier for the provider.
- `DISPLAY_NAME`: A human-readable name for the provider. This name is used for display purposes.

A module provider's constructor receives two parameters:

- `container`: The [module's container](!docs!/learn/fundamentals/modules/container) that contains Framework resources available to the module. You access the following resources:
    - `logger`: A [Logger](!docs!/learn/debugging-and-testing/logging) class to log debug messages.
    - `event_bus`: The [Event Module](../../../infrastructure-modules/event/page.mdx)'s service to emit events.
- `options`: Options that are passed to the module provider when it's registered in Medusa's configurations. You define the following option:
    - `jwtSecret`: A secret used to sign and verify the OTPs.

<Note>

You'll learn how to set this option when you [add the module provider to Medusa's configurations](#h-add-module-provider-to-medusas-configurations).

</Note>

In the constructor, you set the class's properties to the injected dependencies and options.

In the next sections, you'll implement the methods of the `AbstractAuthModuleProvider` class.

<Note>

Refer to the [Create Auth Module Provider](/references/auth/provider) guide for detailed information about the methods.

</Note>

### c. Implement validateOptions Method

The `validateOptions` method is used to validate the options passed to the module provider. If the method throws an error, the Medusa application won't start.

So, add the `validateOptions` method to the `PhoneAuthService` class:

```ts title="src/modules/phone-auth/service.ts"
// other imports...
import { 
  MedusaError,
} from "@medusajs/framework/utils"

class PhoneAuthService extends AbstractAuthModuleProvider {
  // ...
  static validateOptions(options: Record<any, any>): void | never {
    if (!options.jwtSecret) {
      throw new MedusaError(
        MedusaError.Types.INVALID_DATA,
        "JWT secret is required"
      )
    }
  }
}
```

The `validateOptions` method receives the options passed to the module provider as a parameter.

In the method, you throw an error if the `jwtSecret` option is not set.

### d. Implement register Method

When a customer (or another actor type) registers in your application, they must also have an [auth identity](../../../commerce-modules/auth/auth-identity-and-actor-types/page.mdx) that allows them to login.

The `register` method of an auth provider uses custom logic to create the auth identity for the actor type (such as customer). In the method, you can perform custom validation and specify the custom authentication details to store for the user's auth identity.

Medusa uses the `register` method to create an auth identity that will be associated with the customer when they register. You can learn more in the [Authentication Flows](../../../commerce-modules/auth/auth-flows/page.mdx) documentation.

![Diagram showcasing the relation between a customer and auth identity](https://res.cloudinary.com/dza7lstvk/image/upload/v1747747179/Medusa%20Resources/customer-auth-identity_je1bvh.jpg)

So, add the `register` method to the `PhoneAuthService` class:

export const registerHighlights = [
  ["14", "phone", "Extract phone from request body."],
  ["24", "retrieve", "Check if user with phone number already exists."],
  ["33", "create", "Create a new auth identity for the user."],
]

```ts title="src/modules/phone-auth/service.ts" highlights={registerHighlights}
// other imports...
import { 
  AuthenticationInput, 
  AuthIdentityProviderService, 
  AuthenticationResponse, 
} from "@medusajs/types"

class PhoneAuthService extends AbstractAuthModuleProvider {
  // ...
  async register(
    data: AuthenticationInput,
    authIdentityProviderService: AuthIdentityProviderService
  ): Promise<AuthenticationResponse> {
    const { phone } = data.body || {}

    if (!phone) {
      return {
        success: false,
        error: "Phone number is required",
      }
    }

    try {
      await authIdentityProviderService.retrieve({
        entity_id: phone,
      })

      return {
        success: false,
        error: "User with phone number already exists",
      }
    } catch (error) {
      const user = await authIdentityProviderService.create({
        entity_id: phone,
      })

      return {
        success: true,
        authIdentity: user,
      }
    }
  }
}
```

#### Parameters

The `register` method receives an object parameter with the following properties:

- `data`: An object containing properties like `body` that holds request-body parameters. Clients will pass relevant authentication data, such as the user's phone number, in the request body.
- `authIdentityProviderService`: A service injected by the [Auth Module](../../../commerce-modules/auth/page.mdx) that allows you to manage auth identities.

<Note>

The method receives other parameters, which you can find in the [Create Auth Module Provider](/references/auth/provider#register) guide.

</Note>

#### Method Logic

In the method, you extract the `phone` property from the request body, and return an error if it's not provided. You also return an error if another user is using the same phone number.

Otherwise, you create a new auth identity for the user. You set the phone number as the `entity_id` of the auth identity, which is a unique identifier.

#### Return Value

Finally, you return an object with the following properties:

- `success`: A boolean indicating whether the registration was successful.
- `authIdentity`: The created auth identity of the user. This property is only set if the registration was successful.
- `error`: An error message if the registration failed.

### e. Implement authenticate Method

When a customer (or another actor type) logs in, the `authenticate` method of an auth provider is called. This method uses custom logic to authenticate the user.

Authentication providers may implement one of the following flows:

- Direct authentication, where the user is authenticated using this method only. For example, authenticating with an email and password.
- Authentication with callback verification, where the user is authenticated using this method and then a callback is used to verify additional information.

For the Phone Authentication Module Provider, you'll implement the second flow. The user will first be authenticated using the `authenticate` method to make sure the user exists and generate an OTP. Then, they need to supply the OTP to verify their identity.

![Diagram showcasing authentication with callback verification](https://res.cloudinary.com/dza7lstvk/image/upload/v1747749683/Medusa%20Resources/authentication-flow_ey59hw.jpg)

So, add the `authenticate` method to the `PhoneAuthService` class:

export const authenticateHighlights = [
  ["13", "phone", "Extract from request body."],
  ["23", "retrieve", "Check that the user exists."],
  ["33", "generateOTP", "Generate a 6-digit OTP."],
  ["35", "update", "Store OTP in the provider metadat."],
  ["41", "emit", "Emit an event with the generated OTP."],
  ["51", "location", "Indicate that more actions are required."],
  ["55", "generateOTP", "A method to generate the OTP"],
  ["60", "logger", "Log the generated OTP for debugging."],
  ["63", "expiresIn", "Expire the OTP in 60 seconds."]
]

```ts title="src/modules/phone-auth/service.ts" highlights={authenticateHighlights}
// other imports...
import { 
  AuthIdentityDTO,
} from "@medusajs/types"
import jwt from "jsonwebtoken"

class PhoneAuthService extends AbstractAuthModuleProvider {
  // ...
  async authenticate(
    data: AuthenticationInput,
    authIdentityProviderService: AuthIdentityProviderService
  ): Promise<AuthenticationResponse> {
    const { phone } = data.body || {}

    if (!phone) {
      return {
        success: false,
        error: "Phone number is required",
      }
    }

    try {
      await authIdentityProviderService.retrieve({
        entity_id: phone,
      })
    } catch (error) {
      return {
        success: false,
        error: "User with phone number does not exist",
      }
    }

    const { hashedOTP, otp } = await this.generateOTP()

    await authIdentityProviderService.update(phone, {
      provider_metadata: {
        otp: hashedOTP,
      },
    })

    await this.event_bus.emit({
      name: "phone-auth.otp.generated",
      data: {
        otp,
        phone,
      },
    }, {})

    return {
      success: true,
      location: "otp",
    }
  }

  async generateOTP(): Promise<{ hashedOTP: string, otp: string }> {
    // Generate a 6-digit OTP
    const otp = Math.floor(100000 + Math.random() * 900000).toString()

    // for debug
    this.logger.info(`Generated OTP: ${otp}`)
    
    const hashedOTP = jwt.sign({ otp }, this.options.jwtSecret, {
      expiresIn: "60s",
    })
    
    return { hashedOTP, otp }
  }
}
```

You add two methods: the `authenticate` method, and a helper `generateOTP` method.

#### authenticate Parameters

The `authenticate` method receives an object parameter with the following properties:

- `data`: An object containing properties like `body` that holds request-body parameters. Clients will pass relevant authentication data, such as the user's phone number, in the request body.
- `authIdentityProviderService`: A service injected by the [Auth Module](../../../commerce-modules/auth/page.mdx) that allows you to manage auth identities.

<Note>

The method receives other parameters, which you can find in the [Create Auth Module Provider](/references/auth/provider#authenticate) guide.

</Note>

#### authenticate Logic

In the method, you return an error if the `phone` property is not provided in the request body, or if a user with that phone number doesn't exist.

Next, you generate a 6-digit OTP using the `generateOTP` method. Notice that you currently log the OTP for debugging purposes. You can remove this line later once you integrate Twilio.

The OTP is hashed and stored in the `provider_metadata` property of the user's auth identity. The `provider_metadata` property is a JSON object that stores additional information about the auth identity.

Then, you emit an event with the generated OTP and the user's phone number. This allows you later to handle the event and send the OTP to the user using services like Twilio.

#### authenticate Return Value

Finally, you return an object with the following properties:

- `success`: A boolean indicating whether the authentication was successful.
- `location`: A string indicating a URL to perform additional actions in. In this case, you set the location to `otp`, indicating that the user should verify with the OTP.
- `error`: An error message if the authentication failed.

### f. Implement validateCallback Method

When an authentication provider requires a callback to verify the user, the Medusa application calls the `validateCallback` method.

You can use this method to verify the OTP that the user entered. If valid, you return the logged in user, and the Medusa application will return a JWT token that the user can use to authenticate in the application.

![Diagram showcasing how callback verification fits in the authentication flow](https://res.cloudinary.com/dza7lstvk/image/upload/v1747749734/Medusa%20Resources/callback-flow_yney5a.jpg)

So, add the `validateCallback` method to the `PhoneAuthService` class:

export const validateCallbackHighlights = [
  ["7", "phone", "Extract phone from request query."],
  ["7", "otp", "Extract OTP from request query."],
  ["16", "retrieve", "Check that the user exists."],
  ["37", "verify", "Verify that the OTP is correct and hasn't expired."],
  ["52", "update", "Remove OTP from provider metadata."],
]

```ts title="src/modules/phone-auth/service.ts" highlights={validateCallbackHighlights}
class PhoneAuthService extends AbstractAuthModuleProvider {
  // ...
  async validateCallback(
    data: AuthenticationInput,
    authIdentityProviderService: AuthIdentityProviderService
  ): Promise<AuthenticationResponse> {
    const { phone, otp } = data.query || {}

    if (!phone || !otp) {
      return {
        success: false,
        error: "Phone number and OTP are required",
      }
    }

    const user = await authIdentityProviderService.retrieve({
      entity_id: phone,
    })

    if (!user) {
      return {
        success: false,
        error: "User with phone number does not exist",
      }
    }
    
    // verify that OTP is correct
    const userProvider = user.provider_identities?.find((provider) => provider.provider === this.identifier)
    if (!userProvider || !userProvider.provider_metadata?.otp) {
      return {
        success: false,
        error: "User with phone number does not have a phone auth provider",
      }
    }
    
    try {
      const decodedOTP = jwt.verify(
        userProvider.provider_metadata.otp as string, 
        this.options.jwtSecret
      ) as { otp: string }
  
      if (decodedOTP.otp !== otp) {
        throw new Error("Invalid OTP")
      }
    } catch (error) {
      return {
        success: false,
        error: error.message || "Invalid OTP",
      }
    }
    
    const updatedUser = await authIdentityProviderService.update(phone, {
      provider_metadata: {
        otp: null,
      },
    })

    return {
      success: true,
      authIdentity: updatedUser,
    }
  }
}
```

#### Parameters

The `validateCallback` method receives an object parameter with the following properties:

- `data`: An object containing properties like `query` that holds query parameters. Clients will pass relevant authentication data, such as the user's phone number and OTP, in the request query.
- `authIdentityProviderService`: A service injected by the [Auth Module](../../../commerce-modules/auth/page.mdx) that allows you to manage auth identities.

<Note>

The method receives other parameters, which you can find in the [Create Auth Module Provider](/references/auth/provider#validatecallback) guide.

</Note>

#### Method Logic

In the method, you return an error if the phone and otp aren't provided in the request query, or if a user with that phone number doesn't exist.

Next, you verify that the OTP provided by the user is correct. You retrieve the hashed OTP from the `provider_metadata` property of the user's auth identity. If the OTP is not valid, you return an error.

<Note>

Since you set the hash expiration to 60 seconds, the OTP will be valid for 60 seconds. After that, the user will need to request a new OTP.

</Note>

After that, you update the user's auth identity to remove the OTP from the `provider_metadata` property.

#### Return Value

Finally, you return an object with the following properties:

- `success`: A boolean indicating whether the authentication was successful.
- `authIdentity`: The user's auth identity. This property is only set if the authentication was successful.
- `error`: An error message if the authentication failed.

### g. Export Module Definition

You've now finished implementing the necessary methods for the Phone Authentication Module Provider.

The final piece to a module is its definition, which you export in an `index.ts` file at the module's root directory. This definition tells Medusa the name of the module, its service, and optionally its loaders.

To create the module's definition, create the file `src/modules/phone-auth/index.ts` with the following content:

```ts title="src/modules/phone-auth/index.ts"
import PhoneAuthService from "./service"
import { 
  ModuleProvider, 
  Modules,
} from "@medusajs/framework/utils"

export default ModuleProvider(Modules.AUTH, {
  services: [PhoneAuthService],
})
```

You use `ModuleProvider` from the Modules SDK to create the module provider's definition. It accepts two parameters:

1. The name of the module that this provider belongs to, which is `Modules.AUTH` in this case.
2. An object with a required property `services` indicating the module provider's services. Each of these services will be registered as authentication providers in Medusa.

### h. Add Module Provider to Medusa's Configurations

Once you finish building the module, add it to Medusa's configurations to start using it.

In `medusa-config.ts`, add a `modules` property:

```ts title="medusa-config.ts"
// other imports...
import { Modules, ContainerRegistrationKeys } from "@medusajs/framework/utils"

module.exports = defineConfig({
  // ...
  modules: [
    {
      resolve: "@medusajs/medusa/auth",
      dependencies: [
        Modules.CACHE, 
        ContainerRegistrationKeys.LOGGER, 
        Modules.EVENT_BUS,
      ],
      options: {
        providers: [
          // default provider
          {
            resolve: "@medusajs/medusa/auth-emailpass",
            id: "emailpass",
          },
          {
            resolve: "./src/modules/phone-auth",
            id: "phone-auth",
            options: {
              jwtSecret: process.env.PHONE_AUTH_JWT_SECRET || "supersecret",
            },
          },
        ],
      },
    },
  ],
})
```

To pass an Auth Module Provider to the Auth Module, you add the `modules` property to the Medusa configuration and pass the Auth Module in its value.

The Auth Module accepts a `dependencies` option, allowing you to inject dependencies into the containers of the module and its providers. The Auth Module requires passing the [Cache Module](../../../infrastructure-modules/cache/page.mdx) and Logger, but you also inject the `event_bus` dependency to use the Event Module's service in the Phone Authentication Module Provider.

The Auth Module also accepts a `providers` option, which is an array of Auth Module Providers to register. You register the `emailpass` provider, which is registered by default when you don't provide any other providers.

To register the Phone Authentication Module Provider, you add an object to the `providers` array with the following properties:

- `resolve`: The NPM package or path to the module provider. In this case, it's the path to the `src/modules/phone-auth` directory.
- `id`: The ID of the module provider. The auth provider is then registered with the ID `au_{id}`.
- `options`: The options to pass to the module provider. These are the options you defined in the `Options` interface of the module provider's service.

### i. Enable Phone Authentication for Customers

By default, customers and admin users can be authenticated using the `emailpass` provider. When you add a new provider, you need to specify which actor types can use it.

In `medusa-config.ts`, add to `projectConfig.http` a new `authMethodsPerActor` property:

export const authMethodsPerActorHighlights = [
  ["8", "customer", "Enable the emailpass and phone-auth providers for customers."],
]

```ts title="medusa-config.ts" highlights={authMethodsPerActorHighlights}
module.exports = defineConfig({
  projectConfig: {
    // ...
    http: {
      // ...
      authMethodsPerActor: {
        user: ["emailpass"],
        customer: ["emailpass", "phone-auth"],
      },
    },
  },
  // ...
})
```

The `authMethodsPerActor` property is an object whose keys are actor types. The values are arrays of authentication method IDs that can be used for that actor type.

In this case, you enable the `phone-auth` provider for customers. You can also enable it for other actor types, such as admin users or vendors.

### Test Out Phone Authentication

In this section, you'll test out the Phone Authentication Module Provider using Medusa's API routes. You can, instead, test it out later using the [Next.js Starter Storefront](#step-4-use-phone-authentication-in-the-nextjs-starter-storefront).

First, start the Medusa application with the following command:

```bash npm2yarn
npm run start
```

#### Prerequisite: Retrieve Publishable API Key

Before you start testing the authentication provider using the API routes, you need to retrieve your application's publishable API key. This key is necessary to send requests to API routes starting with `/store`.

To retrieve the publishable API key:

1. Open the Medusa Admin dashboard at `http://localhost:9000/admin` and log in.
2. Go to Settings -> Publishable API Keys.
3. Click on the API key in the table.
4. In its details page, click on the API key to copy it.

![Publishable API Key page with the API key clicked](https://res.cloudinary.com/dza7lstvk/image/upload/fl_lossy/f_auto/r_16/ar_16:9,c_pad/v1/User%20Guide/Screenshot_2025-02-25_at_6.14.15_PM_muwq9e.png)

#### a. Retrieve Registration Token

The first step is to retrieve a registration token for a new customer. This token will allow them to register in the application.

To retrieve the registration token, send a `POST` request to `/auth/customer/phone-auth/register`:

```bash
curl -X POST 'http://localhost:9000/auth/customer/phone-auth/register' \
--header 'Content-Type: application/json' \
--data '{
    "phone": "+19077890116"
}'
```

Make sure to replace the phone number with the one you want to use.

This will return a `token` in the response:

```json title="Example Response"
{
  "token": "123..."
}
```

#### b. Register Customer

Next, you'll register the customer using the [Register Customer](!api!/store#customers_postcustomers) API route. You'll pass the registration token you received in the previous step in the header of this request.

So, send a `POST` request to `/store/customers`:

```bash
curl -X POST 'http://localhost:9000/store/customers' \
--header 'x-publishable-api-key: {publishable_api_key}' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer {reg_token}' \
--data-raw '{
    "email": "+19077890116@gmail.com",
    "phone": "19077890116",
    "first_name": "John",
    "last_name": "Smith"
}'
```

Make sure to replace:

- `{publishable_api_key}` with the publishable API key you retrieved from the Medusa Admin dashboard.
- `{reg_token}` with the registration token you received in the previous step.
- The customer details in the request body with the ones you want to use. Use the same phone number you used in the previous step.
    - You pass the email because it's required by the [Register Customer](!api!/store#customers_postcustomers) API route. You set it to the phone number with a `gmail.com` domain.

The request will return the created customer's details:

```json title="Example Response"
{
  "customer": {
    "id": "cus_01JVPESW5SM1MSVPNM2MSC0ZEC",
    "email": "+19077890116@gmail.com",
    "company_name": null,
    "first_name": "John",
    "last_name": "Smith",
    "phone": "19077890116",
    "metadata": null,
    "has_account": true,
    "deleted_at": null,
    "created_at": "2025-05-20T09:01:13.273Z",
    "updated_at": "2025-05-20T09:01:13.273Z",
    "addresses": []
  }
}
```

The customer can now authenticate using the phone number and OTP.

#### c. Authenticate Customer

Next, you'll authenticate the customer using the [Authenticate Customer](!api!/store#auth_postactor_typeauth_provider) API route. This would send the customer an OTP to their phone number (which you'll implement in the next step).

So, send a `POST` request to `/auth/customer/phone-auth`:

```bash
curl -X POST 'http://localhost:9000/auth/customer/phone-auth' \
--header 'Content-Type: application/json' \
--data '{
    "phone": "+19077890116"
}'
```

Make sure to replace the phone number with the one you used to register the customer.

This will return a `location` in the response:

```json title="Example Response"
{
  "location": "otp"
}
```

Indicating that the user should verify their OTP.

<Note>

You can also use this route to resend the OTP if the user didn't receive it or if a minute has passed since the last OTP was sent.

</Note>

#### d. Verify OTP

If you check the logs of the Medusa application, you'll see that the OTP was generated and logged:

```bash
info:    Generated OTP: 576794
```

As mentioned before, this is only for debugging purposes. In the next step, you'll implement the logic to send the OTP to the user using Twilio.

So, to verify the OTP, you'll send a request to the [Verify Callback API route](!api!/store#auth_postactor_typeauth_providercallback):

```bash
curl -X POST 'http://localhost:9000/auth/customer/phone-auth/callback?phone=%2B19077890116&otp=476588'
```

You pass the following query parameters:

- `phone`: The phone number of the customer. Make sure to use the same phone number you used to register the customer, and to encode it. For example, the `+` sign should be encoded as `%2B`.
- `otp`: The OTP that the customer received. Make sure to use the same OTP shown in the logs.

If the OTP is valid, you'll receive a JWT token in the response:

```json title="Example Response"
{
  "token": "123..."
}
```

You can use this token to authenticate the customer in the application. For example, you can use the token to [retrieve the customer's details](!api!/store#customers_getcustomersme).

<Note>

If the OTP has expired, send a request to the [Authenticate Customer](#c-authenticate-customer) API route to generate a new OTP

</Note>

---

## Step 3: Integrate Twilio SMS

Similar to the Auth Module, the [Notification Module](../../../infrastructure-modules/notification/page.mdx) allows registering custom providers to send notifications, such as SMS or email.

In this step, you'll create a Twilio Notification Module Provider, then use it to send the OTP to the customer.

<Prerequisites
  items={[
    {
      text: "Twilio Account",
      link: "https://console.twilio.com/"
    },
    {
      text: "Twilio From Phone Number",
      link: "https://www.twilio.com/docs/phone-numbers"
    },
    {
      text: "Twilio Account SID, which you can retrieve from the Twilio Console homepage.",
      link: "https://www.twilio.com/docs/usage/tutorials/how-to-use-your-free-trial-account-namer#console-dashboard-home-page"
    },
    {
      text: "Twilio Auth Token, which you can retrieve from the Twilio Console homepage.",
      link: "https://www.twilio.com/docs/usage/tutorials/how-to-use-your-free-trial-account-namer#console-dashboard-home-page"
    }
  ]}
/>

### a. Install Twilio SDK

Before you start implementing the Twilio Notification Module Provider, install the Twilio SDK to interact with the Twilio API.

Run the following command in the Medusa application directory:

```bash npm2yarn
npm install twilio
```

You'll use the Twilio SDK in the Notification Module Provider's service.

### b. Create Module Directory

Create the directory `src/modules/twilio-sms` to create the Twilio Notification Module Provider.

### c. Create Notification Module Provider Service

A Notification Module Provider has a service that contains the sending logic. The service must extend the `AbstractNotificationProviderService` class.

So, create the file `src/modules/twilio-sms/service.ts` with the following content:

export const twilioSmsServiceHighlights = [
  ["8", "accountSid", "Twilio account SID."],
  ["9", "authToken", "Twilio auth token."],
  ["10", "from", "Twilio phone number to send the SMS from."],
  ["14", "identifier", "Unique identifier for the module."],
  ["15", "client", "Twilio client to send the SMS."],
]

```ts title="src/modules/twilio-sms/service.ts" highlights={twilioSmsServiceHighlights}
import { 
  AbstractNotificationProviderService,
} from "@medusajs/framework/utils"
import { Twilio } from "twilio"

type InjectedDependencies = {}

type TwilioSmsServiceOptions = {
  accountSid: string
  authToken: string
  from: string
}

class TwilioSmsService extends AbstractNotificationProviderService {
  static readonly identifier = "twilio-sms"
  private readonly client: Twilio
  private readonly from: string

  constructor(container: InjectedDependencies, options: TwilioSmsServiceOptions) {
    super()

    this.client = new Twilio(options.accountSid, options.authToken)
    this.from = options.from
  }
}
```

You'll get a type error about implementing the abstract methods of the `AbstractNotificationProviderService` class, which you'll add in the next steps.

A Notification Module Provider must have an `identifier` static property, which is a unique identifier for the module. This identifier is used to register the module in the Medusa application.

A module provider's constructor receives two parameters:

- `container`: The [module's container](!docs!/learn/fundamentals/modules/container) that contains Framework resources available to the module. You don't need to access any resources for this provider.
- `options`: Options that are passed to the module provider when it's registered in Medusa's configurations. You define the following option:
    - `accountSid`: The Twilio account SID.
    - `authToken`: The Twilio auth token.
    - `from`: The Twilio phone number to send the SMS from.

<Note>

You'll learn how to set these options when you [add the module provider to Medusa's configurations](#g-add-module-provider-to-medusas-configurations).

</Note>

In the constructor, you set the class's properties to the injected dependencies and options.

In the next sections, you'll implement the methods of the `AbstractNotificationProviderService` class.

<Note>

Refer to the [Create Notification Module Provider](/references/notification-provider-module) guide for detailed information about the methods.

</Note>

### d. Implement validateOptions Method

The `validateOptions` method is used to validate the options passed to the module provider. If the method throws an error, the Medusa application won't start.

So, add the `validateOptions` method to the `TwilioSmsService` class:

```ts title="src/modules/twilio-sms/service.ts"
class TwilioSmsService extends AbstractNotificationProviderService {
  // ...
  static validateOptions(options: Record<any, any>): void | never {
    if (!options.accountSid) {
      throw new Error("Account SID is required")
    }
    if (!options.authToken) {
      throw new Error("Auth token is required")
    }
    if (!options.from) {
      throw new Error("From is required")
    }
  }
}
```

The `validateOptions` method receives the options passed to the module provider as a parameter.

In the method, you throw an error if any of the options are not set.

### e. Implement send Method

The only required method for a Notification Module Provider is the `send` method. When the Medusa application needs to send a notification using the provider's channel (such as SMS), it calls this method of the registered provider.

So, add the `send` method to the `TwilioSmsService` class:

export const sendHighlights = [
  ["12", "to", "Extract the phone number to send the SMS to."],
  ["12", "content", "Extract the content of the SMS."],
  ["12", "template", "Extract the template to use for the SMS."],
  ["12", "data", "Extract the data to use in the template."],
  ["13", "contentText", "Set the content text to either the text or template content."],
  ["13", "getTemplateContent", "Get the content for the template."],
  ["17", "message", "Send the SMS using Twilio's client."],
  ["28", "getTemplateContent", "A method to get the content for the template."],
]

```ts title="src/modules/twilio-sms/service.ts" highlights={sendHighlights}
// other imports...
import { 
  ProviderSendNotificationDTO, 
  ProviderSendNotificationResultsDTO,
} from "@medusajs/types"

class TwilioSmsService extends AbstractNotificationProviderService {
  // ...
  async send(
    notification: ProviderSendNotificationDTO
  ): Promise<ProviderSendNotificationResultsDTO> {
    const { to, content, template, data } = notification
    const contentText = content?.text || await this.getTemplateContent(
      template, data
    )

    const message = await this.client.messages.create({
      body: contentText,
      from: this.from,
      to,
    })

    return {
      id: message.sid,
    }
  }

  async getTemplateContent(
    template: string, 
    data?: Record<string, unknown> | null
  ): Promise<string> {
    switch (template) {
      case "otp-template":
        if (!data?.otp) {
          throw new Error("OTP is required for OTP template")
        }

        return `Your OTP is ${data.otp}`
      default:
        throw new Error(`Template ${template} not found`)
    }
  }
}
```

You implement the `send` method and a helper `getTemplateContent` method.

#### send Parameters

The `send` method receives an object parameter with the following properties:

- `to`: The phone number to send the SMS to.
- `content`: An object containing the content of the SMS. The `text` property is the text to send.
- `template`: The template to use for the SMS. This is used to retrieve the fallback content of the SMS if `content.text` is not provided.
- `data`: An object containing the data to use in the template. This is used to replace placeholders in the template with actual values.

<Note>

The method receives other parameters, which you can find in the [Create Notification Module Provider](/references/notification-provider-module#send) guide.

</Note>

#### send Method Logic

In the method, you set the SMS content either to the `text` property of the `content` object or to the template content. You define a `getTemplateContent` method that retrieves the content for a template.

Then, you use the `messages.create` method of the Twilio client to send the SMS. You pass the following parameters:

- `body`: The content of the SMS.
- `from`: The Twilio phone number to send the SMS from.
- `to`: The phone number to send the SMS to.

#### send Return Value

Finally, you return an object that has an `id` property with the ID of the sent SMS. This ID is stored in the notification record in the database.

### f. Export Module Definition

You've now finished implementing the necessary methods for the Twilio Notification Module Provider. You only need to export its definition.

To create the module's definition, create the file `src/modules/twilio-sms/index.ts` with the following content:

```ts title="src/modules/twilio-sms/index.ts"
import { 
  ModuleProvider, 
  Modules,
} from "@medusajs/framework/utils"
import TwilioSMSNotificationService from "./service"

export default ModuleProvider(Modules.NOTIFICATION, {
  services: [TwilioSMSNotificationService],
})
```

You use `ModuleProvider` from the Modules SDK to create the module provider's definition passing it two parameters:

1. The name of the module that this provider belongs to, which is `Modules.NOTIFICATION` in this case.
2. An object with a required property `services` indicating the module provider's services. Each of these services will be registered as notification providers in Medusa.

### g. Add Module Provider to Medusa's Configurations

You'll now add the Twilio Notification Module Provider to Medusa's configurations to start using it.

In `medusa-config.ts`, add the following to the `modules` property:

```ts title="medusa-config.ts"
module.exports = defineConfig({
  // ...
  modules: [
    // ...
    {
      resolve: "@medusajs/medusa/notification",
      options: {
        providers: [
          // default provider
          {
            resolve: "@medusajs/medusa/notification-local",
            id: "local",
            options: {
              name: "Local Notification Provider",
              channels: ["feed"],
            },
          },
          {
            resolve: "./src/modules/twilio-sms",
            id: "twilio-sms",
            options: {
              channels: ["sms"],
              accountSid: process.env.TWILIO_ACCOUNT_SID,
              authToken: process.env.TWILIO_AUTH_TOKEN,
              from: process.env.TWILIO_FROM,
            },
          },
        ],
      },
    },
  ],
})
```

You pass the Notification Module in the `modules` property to register the Twilio Notification Module Provider.

The Notification Module accepts a `providers` option, which is an array of Notification Module Providers to register. You register the `local` provider, which is registered by default when you don't provide any other providers.

To register the Twilio Notification Module Provider, you add an object with the following properties:

- `resolve`: The path to the module provider.
- `id`: The ID of the module provider. The notification provider is then registered with the ID `np_{identifier}_{id}`.
- `options`: The options to pass to the module provider. These include the options you defined in the `Options` interface of the module provider's service.
    - `channels`: The channels that the notification provider supports. In this case, you set it to `sms`, which is the channel used to send SMS notifications.
    - `accountSid`: The Twilio account SID.
    - `authToken`: The Twilio auth token.
    - `from`: The Twilio phone number to send the SMS from.

### h. Add Environment Variables

To set the value of the Twilio options, add the following environment variables to your `.env` file:

```shell title=".env"
TWILIO_ACCOUNT_SID=AC...
TWILIO_AUTH_TOKEN=05...
TWILIO_FROM=+1...
```

Where:

- `TWILIO_ACCOUNT_SID`: The Twilio account SID.
- `TWILIO_AUTH_TOKEN`: The Twilio auth token.
- `TWILIO_FROM`: The Twilio phone number to send the SMS from. Make sure to use the phone number you purchased from Twilio.

You can retrieve these information from the Twilio Console homepage.

![Twilio console homepage showing the account SID, phone number, and auth token](https://res.cloudinary.com/dza7lstvk/image/upload/v1747736641/Medusa%20Resources/CleanShot_2025-05-20_at_13.22.55_2x_sztmfo.png)

### i. Handle OTP Generated Event

Now that you have integrated Twilio into Medusa, you can use it to send the OTP to the customer. To do that, you need to handle the `phone-auth.otp.generated` event that you emitted in the `authenticate` method of the Phone Authentication Module Provider.

You can listen to events in a [subscriber](!docs!/learn/fundamentals/events-and-subscribers). A subscriber is an asynchronous function that listens to events to perform actions when the event is emitted.

In this step, you'll create a subscriber that listens to the `phone-auth.otp.generated` event and sends an SMS to the customer with the OTP.

<Note>

Refer to the [Events and Subscribers](!docs!/learn/fundamentals/events-and-subscribers) documentation to learn more.

</Note>

Subscribers are created in a TypeScript or JavaScript file under the `src/subscribers` directory. So, to create a subscriber, create the file `src/subscribers/send-otp.ts` with the following content:

export const sendOtpHighlights = [
  ["14", "notificationModuleService", "Resolve the Notification Module's service."],
  ["18", "createNotifications", "Send the OTP to the user using Twilio."],
  ["29", `"phone-auth.otp.generated"`, "The event the subscriber is listening to."],
]

```ts title="src/subscribers/send-otp.ts" highlights={sendOtpHighlights}
import {
  SubscriberArgs,
  type SubscriberConfig,
} from "@medusajs/medusa"
import { Modules } from "@medusajs/framework/utils"

export default async function sendOtpHandler({
  event: { data: {
    phone,
    otp,
  } },
  container,
}: SubscriberArgs<{ phone: string, otp: string }>) {
  const notificationModuleService = container.resolve(
    Modules.NOTIFICATION
  )

  await notificationModuleService.createNotifications({
    to: phone,
    channel: "sms",
    template: "otp-template",
    data: {
      otp,
    },
  })
}

export const config: SubscriberConfig = {
  event: "phone-auth.otp.generated",
}
```

The subscriber file must export:

- An asynchronous subscriber function that's executed whenever the associated event is triggered.
- A configuration object with an event property whose value is the event the subscriber is listening to, which is `phone-auth.otp.generated`.

The subscriber function accepts an object with the following properties:

- `event`: An object with the event's data payload. In the `authenticate` method, you emitted the event with the following data:
    - `phone`: The phone number of the user.
    - `otp`: The OTP that was generated.
- `container`: The [Medusa container](!docs!/learn/fundamentals/medusa-container), which you can use to resolve Framework and commerce resources.

In the subscriber function, you resolve the Notification Module's service from the Medusa container. Then, you use its `createNotifications` method to send the OTP to the user.

Under the hood, the Notification Module's service delegates the sending to the Notification Module Provider of the `sms` channel, which is the Twilio Notification Module Provider in this case.

The `createNotifications` method accepts an object with the following properties:

- `to`: The phone number to send the notification to. You use the phone number from the event's data payload.
- `channel`: The channel to use to send the notification, which is `sms`.
- `template`: The template to use for the notification content, which is `otp-template`.
- `data`: An object containing the data to use in the template. You pass the OTP to the template.

### j. Test it Out

To test out the Twilio Notification Module Provider, you can follow the steps in the [Test Out Phone Authentication](#test-out-phone-authentication) section.

After you authenticate the customer, the OTP will be sent to the customer's phone number using Twilio. Then, you can use the OTP to verify the authentication and receive a JWT token.

Alternatively, you can also test it out after customizing the Next.js Starter Storefront, which you'll do in the next step.

<Note>

Make sure to remove the OTP logging line in the `generateOTP` method of the Phone Authentication Module Provider's service now that you have integrated Twilio.

</Note>

---

## Step 4: Use Phone Authentication in the Next.js Starter Storefront

In this step, you'll customize the [Next.js Starter Storefront](../../../nextjs-starter/page.mdx) to allow customers to authenticate using their phone number and OTP.

By default, the Next.js Starter Storefront supports email and password authentication. You'll replace it with phone authentication, but you can also keep both authentication methods if you want to.

<Note title="Reminder" forceMultiline>

The Next.js Starter Storefront was installed in a separate directory from Medusa. The directory's name is `{your-project}-storefront`.

So, if your Medusa application's directory is `medusa-phone-auth`, you can find the storefront by going back to the parent directory and changing to the `medusa-phone-auth-storefront` directory:

```bash
cd ../medusa-phone-auth-storefront # change based on your project name
```

</Note>

### a. Install Phone Input Package

To easily show a phone input where the user can enter their phone number, install the `react-phone-number-input` package:

```bash npm2yarn badgeLabel="Storefront" badgeColor="blue"
npm install react-phone-number-input
```

You'll use it in the login and registration forms to show a phone input.

### b. Add Authenticate Function

Before adding the forms, you'll add the functions that send requests to the Medusa API to authenticate the customer.

The first one you'll add is the `authenticateWithPhone` function, which sends a request to the `/auth/customer/phone-auth` API route to authenticate the customer using their phone number.

In `src/lib/data/customer.ts`, add the following function:

```ts title="src/lib/data/customer.ts" badgeLabel="Storefront" badgeColor="blue"
export const authenticateWithPhone = async (phone: string) => {
  try {
    const response = await sdk.auth.login("customer", "phone-auth", {
      phone,
    })

    if (
      typeof response === "string" || 
      !response.location || 
      response.location !== "otp"
    ) {
      throw new Error("Failed to login")
    }

    return true
  } catch (error: any) {
    return error.toString()
  }
}
```

The function accepts the phone number as a parameter.

In the function, you use the [JS SDK](../../../js-sdk/page.mdx), which is configured within the Next.js Starter Storefront, to send a request to the `/auth/customer/phone-auth` API route. You pass the phone number in the request body.

If the request doesn't return a `location` property set to `otp`, you throw an error. Otherwise, you return `true` to indicate that the request was successful.

### c. add Verify OTP Function

Next, you'll add the `verifyOTP` function, which sends a request to the `/auth/customer/phone-auth/callback` API route to verify the OTP.

In `src/lib/data/customer.ts`, add the following function:

export const verifyOtpHighlights = [
  ["9", "callback", "Verify the OTP using the callback API route."],
  ["14", "setAuthToken", "Set the authentication token."],
  ["17", "revalidateTag", "Revalidate the customer cache tag to refresh customer-related UI."],
  ["19", "transferCart", "Transfer the cart from guest to authenticated customer."],
]

```ts title="src/lib/data/customer.ts" badgeLabel="Storefront" badgeColor="blue" highlights={verifyOtpHighlights}
export const verifyOtp = async ({
  otp,
  phone,
}: {
  otp: string
  phone: string
}) => {
  try {
    const token = await sdk.auth.callback("customer", "phone-auth", {
      phone,
      otp,
    })

    await setAuthToken(token)

    const customerCacheTag = await getCacheTag("customers")
    revalidateTag(customerCacheTag)

    await transferCart()

    return true
  } catch (e: any) {
    return e.toString()
  }  
}
```

The function accepts an object with the following properties:

- `otp`: The OTP to verify.
- `phone`: The phone number of the customer.

In the function, you use the JS SDK to send a request to the `/auth/customer/phone-auth/callback` API route. You pass the phone number and OTP in the request body.

If the request is successful and you receive a token, you set the token in the cookies and refresh the customer cache. This ensures that all customer-related UI is updated after logging in, such as showing the customer's profile when accessing the `/account` page.

Then, you call the `transferCart` function to transfer the cart from the guest user to the authenticated customer.

Finally, you return `true` to indicate that the request was successful.

### d. Add Registration Function

The last function you'll add is the `registerWithPhone` function, which will register the customer using their phone number.

In `src/lib/data/customer.ts`, add the following function:

export const registerWithPhoneHighlights = [
  ["11", "regToken", "Retrieve the registration token."],
  ["20", "setAuthToken", "Set the authentication token."],
  ["33", "create", "Create the customer."],
  ["39", "authenticateWithPhone", "Authenticate the customer using their phone number."],
]

```ts title="src/lib/data/customer.ts" badgeLabel="Storefront" badgeColor="blue" highlights={registerWithPhoneHighlights}
export const registerWithPhone = async ({
  firstName,
  lastName,
  phone,
}: {
  firstName: string
  lastName: string
  phone: string
}) => {
  try {
    const { token: regToken } = await sdk.client.fetch<
      { token: string }
    >(`/auth/customer/phone-auth/register`, {
      method: "POST",
      body: {
        phone,
      },
    })
    
    await setAuthToken(regToken as string)
    const headers = {
      ...(await getAuthHeaders()),
    }

    const email = `${phone}@gmail.com`
    const customerData = {
      email,
      first_name: firstName,
      last_name: lastName,
      phone,
    }
    
    await sdk.store.customer.create(
      customerData,
      {},
      headers
    )

    return await authenticateWithPhone(phone)
  } catch (error: any) {
    return error.toString()
  }
}
```

The function accepts an object with the following properties:

- `firstName`: The first name of the customer.
- `lastName`: The last name of the customer.
- `phone`: The phone number of the customer.

In the function, you retrieve a registration token for the customer using the `/auth/customer/phone-auth/register` API route. You pass the phone number in the request body.

Then, after setting the registration token in the cookies, you create a customer using the [Create Customer](!api!/store#customers_postcustomers) API route. You pass the following properties in the request body:

- `email`: The email of the customer. You set it to the phone number with a `@gmail.com` domain.
- `first_name`: The first name of the customer.
- `last_name`: The last name of the customer.
- `phone`: The phone number of the customer.

Finally, you call the `authenticateWithPhone` function to authenticate the customer using their phone number. At this step, the customer would receive an OTP to login.

### e. Add OTP Form

Next, you'll add an OTP form that allows the customer to enter the OTP they receive after login or registration. Later, you'll reuse this form in both the login and registration pages.

Create the file `src/modules/account/components/otp/index.tsx` with the following content:

export const otpHighlights = [
  ["13", "otp", "The OTP entered by the customer."],
  ["14", "error", "The error message to show if the OTP verification fails."],
  ["15", "isLoading", "A boolean indicating whether the OTP verification is in progress."],
  ["16", "countdown", "The countdown timer for resending the OTP."],
  ["17", "inputRefs", "A ref to store the input elements for the OTP digits."],
  ["19", "handleSubmit", "Verify OTP on submission."],
  ["33", "handleResend", "Resend OTP to the customer."],
  ["38", "handlePaste", "Improve paste experience for OTP input."],
]

```tsx title="src/modules/account/components/otp/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={otpHighlights}
"use client"

import { Input } from "@medusajs/ui"
import { useState, useRef, useEffect } from "react"
import { authenticateWithPhone, verifyOtp } from "../../../../lib/data/customer"
import ErrorMessage from "../../../checkout/components/error-message"

type Props = {
  phone: string
}

export const Otp = ({ phone }: Props) => {
  const [otp, setOtp] = useState<string>("")
  const [error, setError] = useState<string>("")
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [countdown, setCountdown] = useState<number>(60)
  const inputRefs = useRef<(HTMLInputElement | null)[]>([])

  const handleSubmit = async () => {
    setIsLoading(true)
    const response = await verifyOtp({
      otp,
      phone,
    })
    setOtp("")
    setIsLoading(false)

    if (typeof response === "string") {
      setError(response)
    }
  }

  const handleResend = async () => {
    authenticateWithPhone(phone)
    setCountdown(60)
  }

  const handlePaste = (e: React.ClipboardEvent) => {
    e.preventDefault()
    const pastedData = e.clipboardData.getData("text")
    const numericValue = pastedData.replace(/\D/g, "").slice(0, 6)
    
    if (numericValue) {
      setOtp(numericValue)
      // Focus the next empty input after pasted content
      const nextEmptyIndex = Math.min(numericValue.length, 5)
      inputRefs.current[nextEmptyIndex]?.focus()
    }
  }

  // TODO add use effects
}
```

You create an `Otp` component that accepts the phone number as a prop.

In the component, you define the following state variables:

- `otp`: The OTP entered by the customer.
- `error`: The error message to show if the OTP verification fails.
- `isLoading`: A boolean indicating whether the OTP verification is in progress.
- `countdown`: The countdown timer for resending the OTP.
- `inputRefs`: A ref to store the input elements for the OTP digits. You'll show six input elements for the OTP digits.

You also define the following functions:

- `handleSubmit`: This function is called when the customer submits the OTP. It calls the `verifyOtp` function to verify the OTP entered by the customer.
- `handleResend`: This function is called when the customer clicks the "Resend OTP" button that you'll add later. It calls the `authenticateWithPhone` function to resend the OTP to the customer's phone number.
- `handlePaste`: This function is called when the customer pastes the OTP in the input field. It improves the experience of pasting the OTP without having to enter it manually.

#### Handle Variable Changes

Next, you'll add `useEffect` hooks to handle changes in the state variables.

Replace the `TODO` with the following:

export const useEffectHighlights = [
  ["1", "useEffect", "Focus the first input element when the component mounts."],
  ["7", "useEffect", "Automatically submit the OTP when the customer enters six digits."],
  ["15", "useEffect", "Add an interval to update the countdown timer every second."],
]

```tsx title="src/modules/account/components/otp/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={useEffectHighlights}
useEffect(() => {
  if (inputRefs.current[0]) {
    inputRefs.current[0].focus()
  }
}, [inputRefs.current])

useEffect(() => {
  if (otp.length !== 6 || isLoading) {
    return
  }

  handleSubmit()
}, [otp, isLoading])

useEffect(() => {
  const timer = setInterval(() => {
    setCountdown((prev) => {
      return prev > 0 ? prev - 1 : 0
    })
  }, 1000)

  return () => clearInterval(timer)
}, [])

// TODO render form
```

You add three `useEffect` hooks:

1. The first one focuses the first input element when the component mounts.
2. The second one automatically submits the OTP when the customer enters six digits.
3. The third one adds an interval to update the countdown timer every second.

### f. Render OTP Form

Lastly, you'll render the OTP form with the input elements and the resend button.

Replace the `TODO` with the following:

```tsx title="src/modules/account/components/otp/index.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div
    className="max-w-sm flex flex-col items-center"
    data-testid="otp-page"
  >
    <h1 className="text-large-semi uppercase mb-6">
      Verify Phone Number
    </h1>
    <p className="text-center text-base-regular text-ui-fg-base mb-4">
      Enter the code sent to your phone number to login.
    </p>
    <div className="flex gap-2 mb-4">
      {[...Array(6)].map((_, index) => (
        <Input
          key={index}
          type="text"
          maxLength={1}
          pattern="\d*"
          inputMode="numeric"
          disabled={isLoading}
          className="w-10 h-10 text-center"
          ref={(el) => {
            inputRefs.current[index] = el
          }}
          onPaste={handlePaste}
          value={otp[index] || ""}
          onChange={(e) => {
            const elm = e.target
            const value = elm.value
            setOtp((prev) => {
              const newOtp = prev.split("")
              newOtp[index] = value
              return newOtp.join("")
            })
            if (value && /^\d+$/.test(value)) {
              // Move focus to next input
              const nextInput = elm.parentElement?.nextElementSibling?.querySelector("input")
              nextInput?.focus()
            }
          }}
          onKeyDown={(e) => {
            if (e.key === "Backspace" && !e.currentTarget.value) {
              // Move focus to previous input on backspace
              const prevInput = e.currentTarget.parentElement?.previousElementSibling?.querySelector("input")
              prevInput?.focus()
            }
          }}
        />
      ))}        
    </div>
    <div className="flex items-center gap-x-2 mb-4">
      <button
        className="text-small-regular text-ui-fg-interactive disabled:text-ui-fg-disabled disabled:cursor-not-allowed"
        onClick={handleResend}
        disabled={countdown > 0}
      >
        {countdown > 0 ? `Resend code in ${countdown}s` : "Resend Code"}
      </button>
    </div>
    <ErrorMessage error={error} />
  </div>
)
```

You show six input elements for the OTP digits. When a value is entered in an input, the focus moves to the next input. In addition, when the customer presses backspace on an empty input, the focus moves to the previous input. 

You also show a resend button that allows the customer to resend the OTP once the countdown timer reaches zero.

You now have an OTP form that you can use in both the login and registration pages.

### g. Add Registration Form

You'll now add a registration form that allows the customer to register using their phone number.

First, in `src/modules/account/templates/login-template.tsx`, update the `LOGIN_VIEW` to the following:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={[["4"], ["5"]]}
export enum LOGIN_VIEW {
  SIGN_IN = "sign-in",
  REGISTER = "register",
  REGISTER_PHONE = "register-phone",
  SIGN_IN_PHONE = "sign-in-phone",
}
```

By default, the login template supports switching between the login and registration views for email and password authentication. With the above change, you add two new views: login and registration with phone number.

Then, to add the registration form, create the file `src/modules/account/components/register-phone/index.tsx` with the following content:

export const registerPhoneHighlights = [
  ["20", "firstName", "The first name of the customer."],
  ["21", "lastName", "The last name of the customer."],
  ["22", "phone", "The phone number of the customer."],
  ["23", "error", "The error message to show if the registration fails."],
  ["24", "loading", "A boolean indicating whether the registration is in progress."],
  ["25", "enterOtp", "A boolean indicating whether to show the OTP form."],
  ["26", "countryCode", "The country code of the customer."],
  ["28", "handleSubmit", "Register customer on form submision."],
  ["45", "enterOtp", "Show the OTP form after successful registration."],
]

```tsx title="src/modules/account/components/register-phone/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={registerPhoneHighlights}
"use client"

import { useState } from "react"
import Input from "@modules/common/components/input"
import { LOGIN_VIEW } from "@modules/account/templates/login-template"
import ErrorMessage from "@modules/checkout/components/error-message"
import LocalizedClientLink from "@modules/common/components/localized-client-link"
import { registerWithPhone } from "@lib/data/customer"
import "react-phone-number-input/style.css"
import PhoneInput from "react-phone-number-input"
import { Otp } from "../otp"
import { useParams } from "next/navigation"
import { Button } from "@medusajs/ui"

type Props = {
  setCurrentView: (view: LOGIN_VIEW) => void
}

const RegisterPhone = ({ setCurrentView }: Props) => {
  const [firstName, setFirstName] = useState("")
  const [lastName, setLastName] = useState("")
  const [phone, setPhone] = useState("")
  const [error, setError] = useState("")
  const [loading, setLoading] = useState(false)
  const [enterOtp, setEnterOtp] = useState(false)
  const { countryCode } = useParams() as { countryCode: string }

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    setLoading(true)
    const response = await registerWithPhone({
      firstName,
      lastName,
      phone,
    })
    setLoading(false)
    if (typeof response === "string") {
      setError(response)
      return
    }

    setEnterOtp(true)
  }

  if (enterOtp) {
    return <Otp phone={phone} />
  }

  // TODO render form
}

export default RegisterPhone
```

You create a `RegisterPhone` component that accepts a `setCurrentView` prop to switch between the login and registration views.

In the component, you define the following state variables:

- `firstName`, `lastName`, and `phone` to store the form inputs' values.
- `error`: The error message to show if the registration fails.
- `loading`: A boolean indicating whether the registration is in progress.
- `enterOtp`: A boolean indicating whether to show the OTP form. This is enabled once the customer is registered and they need to authenticate using the OTP.
- `countryCode`: The country code of the customer, which is retrieved from the URL parameters. You'll use this to show the phone input with a default selected country.

You also define a `handleSubmit` function that handles the form submission. It calls the `registerWithPhone` function to register the customer using their phone number.

If the registration is successful, you set `enterOtp` to `true` to show the OTP form. Otherwise, you set the error message.

#### Render Registration Form

Next, you'll render the registration form with the input fields and the submit button.

Replace the `TODO` with the following:

```tsx title="src/modules/account/components/register-phone/index.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div
    className="max-w-sm flex flex-col items-center"
    data-testid="register-page"
  >
    <h1 className="text-large-semi uppercase mb-6">
      Become a Medusa Store Member
    </h1>
    <p className="text-center text-base-regular text-ui-fg-base mb-4">
      Create your Medusa Store Member profile, and get access to an enhanced
      shopping experience.
    </p>
    <form className="w-full flex flex-col" onSubmit={handleSubmit}>
      <div className="flex flex-col w-full gap-y-2">
        <Input
          label="First name"
          name="first_name"
          required
          autoComplete="given-name"
          data-testid="first-name-input"
          value={firstName}
          onChange={(e) => setFirstName(e.target.value)}
        />
        <Input
          label="Last name"
          name="last_name"
          required
          autoComplete="family-name"
          data-testid="last-name-input"
          value={lastName}
          onChange={(e) => setLastName(e.target.value)}
        />
        <PhoneInput
          placeholder="Enter phone number"
          value={phone}
          onChange={(value) => setPhone(value as string)}
          name="phone"
          required
          autoComplete="off"
          // @ts-ignore
          defaultCountry={countryCode.toUpperCase()}
        />
      </div>
      <ErrorMessage error={error} data-testid="register-error" />
      <span className="text-center text-ui-fg-base text-small-regular mt-6">
        By creating an account, you agree to Medusa Store&apos;s{" "}
        <LocalizedClientLink
          href="/content/privacy-policy"
          className="underline"
        >
          Privacy Policy
        </LocalizedClientLink>{" "}
        and{" "}
        <LocalizedClientLink
          href="/content/terms-of-use"
          className="underline"
        >
          Terms of Use
        </LocalizedClientLink>
        .
      </span>
      <Button 
        className="w-full mt-6" 
        type="submit"
        size="large"
        variant="primary"
        isLoading={loading}
      >
        Join
      </Button>
    </form>
    <span className="text-center text-ui-fg-base text-small-regular mt-6">
      Already a member?{" "}
      <button
        onClick={() => setCurrentView(LOGIN_VIEW.SIGN_IN_PHONE)}
        className="underline"
      >
        Sign in
      </button>
      .
    </span>
  </div>
)
```

You render the registration form with input fields for the first name, last name, and phone number.

For the phone number input, you use the `PhoneInput` component from the `react-phone-number-input` package. You set the `defaultCountry` prop to the country code retrieved from the URL parameters.

You also show a submit button that calls the `handleSubmit` function when clicked, and a button to switch to the login form.

#### Add to Login Template

Next, you'll add the `RegisterPhone` component to the login template.

In `src/modules/account/templates/login-template.tsx`, add the following import:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
import RegisterPhone from "@modules/account/components/register-phone"
```

Then, change the `return` statement of the `LoginTemplate` component to the following:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div className="w-full flex justify-start px-8 py-8">
    {currentView === "sign-in" ? (
      <Login setCurrentView={setCurrentView} />
    ) : currentView === "register" ? (
      <Register setCurrentView={setCurrentView} />
    ) : currentView === "register-phone" ? (
      <RegisterPhone setCurrentView={setCurrentView} />
    ) : (
      // TODO: Add login phone view
      <></>
    )}
  </div>
)
```

You show the registration form when the `currentView` is set to `register-phone`. You'll also add the login form later.

### h. Add Login Form

Next, you'll add a login form that allows the customer to log in using their phone number.

To create the form, create the file `src/modules/account/components/login-phone/index.tsx` with the following content:

export const loginPhoneHighlights = [
  ["18", "phone", "The phone number entered by the customer."],
  ["19", "error", "The error message to show if the login fails."],
  ["20", "loading", "A boolean indicating whether the login is in progress."],
  ["21", "enterOtp", "A boolean indicating whether to show the OTP form."],
  ["22", "countryCode", "The country code of the customer."],
  ["24", "handleSubmit", "Authenticate customer on form submission."],
  ["37", "enterOtp", "Show the OTP form after successful login."],
]

```tsx title="src/modules/account/components/login-phone/index.tsx" badgeLabel="Storefront" badgeColor="blue" highlights={loginPhoneHighlights}
"use client"

import { authenticateWithPhone } from "@lib/data/customer"
import { LOGIN_VIEW } from "@modules/account/templates/login-template"
import ErrorMessage from "@modules/checkout/components/error-message"
import { useState } from "react"
import "react-phone-number-input/style.css"
import PhoneInput from "react-phone-number-input"
import { Otp } from "../otp"
import { useParams } from "next/navigation"
import { Button } from "@medusajs/ui"

type Props = {
  setCurrentView: (view: LOGIN_VIEW) => void
}

const LoginPhone = ({ setCurrentView }: Props) => {
  const [phone, setPhone] = useState("")
  const [error, setError] = useState("")
  const [loading, setLoading] = useState(false)
  const [enterOtp, setEnterOtp] = useState(false)
  const { countryCode } = useParams() as { countryCode: string }

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    setLoading(true)
    const response = await authenticateWithPhone(phone)
    setLoading(false)
    if (typeof response === "string") {
      setError(response)
      return
    }

    setEnterOtp(true)
  }

  if (enterOtp) {
    return <Otp phone={phone} />
  }

  // TODO render form
}

export default LoginPhone
```

You create a `LoginPhone` component that accepts a `setCurrentView` prop to switch between the login and registration views.

In the component, you define the following state variables:

- `phone`: The phone number entered by the customer.
- `error`: The error message to show if the login fails.
- `loading`: A boolean indicating whether the login is in progress.
- `enterOtp`: A boolean indicating whether to show the OTP form. This is enabled after the form is submitted.
- `countryCode`: The country code of the customer, which is retrieved from the URL parameters. You'll use this to show the phone input with a default selected country.

You also define a `handleSubmit` function that handles the form submission. It calls the `authenticateWithPhone` function to authenticate the customer using their phone number. Then, it enables `enterOtp` to show the OTP form.

#### Render Login Form

Next, you'll render the login form with the input field and the submit button.

Replace the `TODO` with the following:

```tsx title="src/modules/account/components/login-phone/index.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div
    className="max-w-sm w-full flex flex-col items-center"
    data-testid="login-page"
  >
    <h1 className="text-large-semi uppercase mb-6">Welcome back</h1>
    <p className="text-center text-base-regular text-ui-fg-base mb-8">
      Sign in to access an enhanced shopping experience.
    </p>
    <form className="w-full" onSubmit={handleSubmit}>
      <div className="flex flex-col w-full gap-y-2">
        <PhoneInput
          placeholder="Enter phone number"
          value={phone}
          onChange={(value) => setPhone(value as string)}
          name="phone"
          required
          // @ts-ignore
          defaultCountry={countryCode.toUpperCase()}
        />
      </div>
      {error && <ErrorMessage error={error} data-testid="login-error-message" />}
      <Button 
        className="w-full mt-6" 
        disabled={loading}
        type="submit"
        size="large"
        variant="primary"
        isLoading={loading}
      >
        Sign in
      </Button>
    </form>
    <span className="text-center text-ui-fg-base text-small-regular mt-6">
      Not a member?{" "}
      <button
        onClick={() => setCurrentView(LOGIN_VIEW.REGISTER_PHONE)}
        className="underline"
        data-testid="register-button"
      >
        Join us
      </button>
      .
    </span>
  </div>
)
```

You render the login form with an input field for the phone number. You also show a submit button that calls the `handleSubmit` function when clicked.

### i. Add to Login Template

Next, you'll add the `LoginPhone` component to the login template.

In `src/modules/account/templates/login-template.tsx`, add the following import:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
import LoginPhone from "../components/login-phone"
```

Next, in the `LoginTemplate` component, change the default value of the `currentView` state to `LOGIN_VIEW.SIGN_IN_PHONE`:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
const [currentView, setCurrentView] = useState(LOGIN_VIEW.SIGN_IN_PHONE)
```

This ensures the phone login form is shown by default.

Finally, replace the `return` statement of the `LoginTemplate` component to the following:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div className="w-full flex justify-start px-8 py-8">
    {currentView === "sign-in" ? (
      <Login setCurrentView={setCurrentView} />
    ) : currentView === "register" ? (
      <Register setCurrentView={setCurrentView} />
    ) : currentView === "register-phone" ? (
      <RegisterPhone setCurrentView={setCurrentView} />
    ) : (
      <LoginPhone setCurrentView={setCurrentView} />
    )}
  </div>
)
```

You show the login form when the `currentView` is set to `sign-in-phone`.

### Test it Out

You can now test out the phone authentication feature in the Next.js Starter Storefront.

First, start the Medusa application by running the following command in the Medusa project's directory:

```bash npm2yarn badgeLabel="Medusa Application" badgeColor="green"
npm run dev
```

Then, start the Next.js Starter Storefront by running the following command in the storefront project's directory:

```bash npm2yarn badgeLabel="Storefront" badgeColor="blue"
npm run dev
```

Open your browser, navigate to `http://localhost:8000`, and click on the "Account" link at the top right. This will show the login form with just the phone number input.

![Login form with phone number input](https://res.cloudinary.com/dza7lstvk/image/upload/v1747739945/Medusa%20Resources/CleanShot_2025-05-20_at_14.18.36_2x_ubuika.png)

You can also switch to the registration form by clicking on the "Join" link below the login form.

![Registration form with phone number input](https://res.cloudinary.com/dza7lstvk/image/upload/v1747739988/Medusa%20Resources/CleanShot_2025-05-20_at_14.19.35_2x_btlc2s.png)

You can try to login with the account you created before, or register with a new one. Once successful, you'll see the OTP form to enter the OTP you received as SMS.

![OTP form](https://res.cloudinary.com/dza7lstvk/image/upload/v1747740102/Medusa%20Resources/CleanShot_2025-05-20_at_14.21.18_2x_yrkuyg.png)

After you enter the six digits, you'll be logged in and you'll see your profile page.

![Profile page](https://res.cloudinary.com/dza7lstvk/image/upload/v1747740166/Medusa%20Resources/CleanShot_2025-05-20_at_14.22.30_2x_kshb83.png)

---

## Step 5: Disallow Phone Updates

The phone authentication feature is now complete, but there are two improvements you can make:

1. Show the phone number in the profile page: Currently, it shows the email address, which is a fake address you've set.
2. Disable phone and email updates: Currently, the customer can update their phone number, which is not allowed for phone authentication.

### a. Show Phone Number in Profile Page

To show the phone number in the profile page instead of the email, in `src/modules/account/components/overview/index.tsx`, find the following in the `return` statement:

```tsx title="src/modules/account/components/overview/index.tsx" badgeLabel="Storefront" badgeColor="blue"
<span
  className="font-semibold"
  data-testid="customer-email"
  data-value={customer?.email}
>
  {customer?.email}
</span>
```

And replace it with the following:

```tsx title="src/modules/account/components/overview/index.tsx" badgeLabel="Storefront" badgeColor="blue"
<span
  className="font-semibold"
  data-testid="customer-phone"
  data-value={customer?.phone}
>
  {customer?.phone}
</span>
```

If you check the profile page now, you'll see the phone number instead of the email address at the top right.

![Phone number showing in profile page](https://res.cloudinary.com/dza7lstvk/image/upload/v1747740378/Medusa%20Resources/CleanShot_2025-05-20_at_14.25.59_2x_x0pxvt.png)

### b. Remove Email and Phone Fields

Next, you'll remove the fields to update email and phone number from the profile page.

In `src/app/[countryCode]/(main)/account/@dashboard/profile/page.tsx`, find the following lines to remove from the `return` statement:

```tsx title="src/app/[countryCode]/(main)/account/@dashboard/profile/page.tsx" badgeLabel="Storefront" badgeColor="blue"
<div className="flex flex-col gap-y-8 w-full">
  {/* ... */}
  {/* Remove the following */}
  <Divider />
  <ProfileEmail customer={customer} />
  <Divider />
  <ProfilePhone customer={customer} />
  {/* ... */}
</div>
```

If you go to your profile page and click on "Profile" in the sidebar, the email and phone number sections will be removed.

![Profile page without email and phone fields](https://res.cloudinary.com/dza7lstvk/image/upload/v1747740515/Medusa%20Resources/CleanShot_2025-05-20_at_14.28.09_2x_ugab7d.png)

### c. Disable Phone Updates in Medusa

While removing the email and phone fields from the profile page prevents customers using the storefront from updating their phone number, it doesn't prevent them from updating it using Medusa's API.

In this section, you'll add a [middleware](!docs!/learn/fundamentals/api-routes/middlewares) to the `/store/customers/me` API route that prevents customers from updating their phone number.

A middleware is a function that's executed whenever a request is sent to an API route. It's executed before the route handler, allowing you to validate requests, apply authentication guards, and more.

<Note>

Learn more in the [Middlewares](!docs!/learn/fundamentals/api-routes/middlewares) documentation.

</Note>

To add a middleware in your Medusa application, create the file `src/api/middlewares.ts` with the following content:

```ts title="src/api/middlewares.ts" badgeLabel="Medusa Application" badgeColor="green"
import { defineMiddlewares } from "@medusajs/framework/http"

export default defineMiddlewares({
  routes: [
    {
      matcher: "/store/customers/me",
      method: ["POST"],
      middlewares: [
        async (req, res, next) => {
          const { phone } = req.body as Record<string, string>

          if (phone) {
            return res.status(400).json({
              error: "Phone number is not allowed to be updated",
            })
          }

          next()
        },
      ],
    },
  ],
})
```

You define middlewares using the `defineMiddlewares` function. It accepts an object having a `routes` property that holds all middlewares applied to API routes.

Each object in `routes` has the following properties:

- `matcher`: The API route path to apply the middleware on. You set it to `/store/customers/me`.
- `method`: The HTTP method to apply the middleware to. You set it to `POST` so that the middleware is applied only on `POST` requests sent to the `/store/customers/me` route.
- `middlewares`: An array of middlewares to apply on the route. You add a middleware that throws an error if the request body contains a `phone` property. This prevents customers from updating their phone number using the API.

Any `POST` request to the `/store/customers/me` route will now be validated to ensure it's not updating the phone number.

---

## Next Steps

You've now implemented phone authentication in Medusa with Twilio integration. You can further customize the phone authentication feature based on your business use case.

### Authenticate Other Actor Types

This tutorial focused on authenticating customers using their phone number. However, you can also authenticate other actor types, such as admin users and vendors.

To do that, first, enable the `phone-auth` authentication strategy in `medusa-config.ts` for the actor types. For example:

```ts title="medusa-config.ts"
module.exports = defineConfig({
  projectConfig: {
    // ...
    http: {
      // ...
      authMethodsPerActor: {
        user: ["emailpass", "phone-auth"],
        customer: ["emailpass", "phone-auth"],
        vendor: ["emailpass", "phone-auth"],
      },
    },
  },
})
```

Then, when sending requests to the authentication API routes mentioned in the [Test Out Phone Authentication](#test-out-phone-authentication) section, replace `customer` in the API route paths with the actor type you want to authenticate:

- `/auth/customer/phone-auth/register` -> `/auth/user/phone-auth/register`
- `/auth/customer/phone-auth` -> `/auth/user/phone-auth`
- `/auth/customer/phone-auth/callback` -> `/auth/user/phone-auth/callback`

Finally, update the UI to show the phone authentication option for the actor type you want to authenticate. This depends on the UI you're using, but you can follow an approach similar to the Next.js Starter Storefront customizations.

<Note>

The login form of Medusa Admin can't be customized, so you'll have to build a custom admin dashboard to support phone authentication for admin users.

</Note>

### Learn More about Medusa

If you're new to Medusa, check out the [main documentation](!docs!/learn), where you'll get a more in-depth learning of all the concepts you've used in this guide and more.

To learn more about the commerce features that Medusa provides, check out Medusa's [Commerce Modules](../../../commerce-modules/page.mdx).

### Troubleshooting

If you encounter issues during your development, check out the [troubleshooting guides](../../../troubleshooting/page.mdx).

### Getting Help

If you encounter issues not covered in the troubleshooting guides:

1. Visit the [Medusa GitHub repository](https://github.com/medusajs/medusa) to report issues or ask questions.
2. Join the [Medusa Discord community](https://discord.gg/medusajs) for real-time support from community members.
3. Contact the [sales team](https://medusajs.com/contact/) to get help from the Medusa team.
